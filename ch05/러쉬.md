### 5.1 트랜잭션
- MyISAM은 트랜잭션을 지원하지 않는다.
- InnoDB는 트랜잭션을 지원한다.
### 5.1.1 MySQL에서의 트랜잭션
- 하나의 논리적인 작업 셋에 하나의 쿼리가 있는 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야함을 보장해 주는 것이다.
- MyISAM은 쿼리문 실행 도중 오류가 발생해도, 이전 성공한 부분은 그대로 남아있다. 
	- 부분 업데이트(Partial Update)라고 표현한다. 
	- 이러한 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.
- 트랜잭션은 어플리케이션 개발에서 고민해야 할 문제를 줄여주는 필수적인 DBMS 기능이다.
	- 실행하는 쿼리가 하나뿐이라면 재처리 작업은 간단하다.
### 5.1.2 주의사항
- 트랜잭션 또한 DBMS의 커넥션과 동일하게 필요한 최소의 코드에만 적용하는 것이 좋다.
	-> 프로그램 코드에서 트랜잭션의 범위를 최소화하자!
	1. 데이터베이스의 커넥션 생성하는 코드를 트랜잭션에 포한할 경우
		- 데이터베이스 커넥션 개수는 제한적이다, 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어든다.
	2. 네트워크 통신을 트랜잭션에 포함하는 경우
		- 프로그램이 실행되는 동은 외부 서버와 통신할 수 없는 상황이 발생한다면, 웹 서버뿐 아니라 DBMS 서버까지 위험해진다.
	3. 여러 작업을 하나의 트랜잭션으로 묶는 경우
		- 별도의 트랜잭션으로 분리하자
### 5.2 MySQL 엔진의 잠금
1. 스토리지 엔진 레벨의 잠금
	- 스토리지 엔진간 상호 영향을 미치지 않는다.
2. MySQL 엔진 레벨의 잠금
	- 모든 스토리지 엔진에 영향을 미친다.
### 5.2.1 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령어로 획득 가능하다.
- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
- 영향 범위: MySQL 서버 전체
- 여러 DB에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.

- MySQL 8.0부터는 트랜잭션을 지원하는 InnoDB가 기본 스토리지 엔진으로 사용된다
	-> 더 가벼운 글로벌 락의 필요성이 생겼다.
	-> Xtrabackup이나 Enterprise BackUp과 같은 백업 툴들의 안정적인 실행을 위해 **백업 락**이 도입됐다.
- 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
	- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
	- REPAIR TABLE과 OPTIMIZE TABLE 명령
	- 사용자 관리 및 비밀번호 변경
- 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.
- MySQL 서버의 구성은 소스 서버(Source Server) 와 레플리카(Replica Server)로 구성된다. 
	- 백업은 주로 레플리카 서버에서 진행된다.
	- 문제점
		- 글로벌 락을 획득하면 본제는 백업 시간만큼 지연된다.
		- 레플리카 서버에서 백업을 실행하는 도중에 소스 서버에 문제가 생기면 레플리카 최신화까지 서비스를 멈춰야 할 수 있다. 
		- XtraBackup이나 Enterprise Back 툴이 실행되는 도중에 스키마 변경이 실행되면 백업은 실패한다.
		-> 백업 락은 등장 이유: 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.
### 5.2.2 테이블 락
개별 테이블 단위로 설정되는 잠금
- 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 

명시적인 락
- 명시적: LOCK TABLES table_name [READ | WRITE]
- 반납 해제: UNLOCK TABLES
* 명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.
	-> 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.

묵시적인 락
- MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다.
- 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 쿼리가 완료된 후 자동 해제된다.
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 묵시적인 테이블 락이 설정되지 않는다.
	-> InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

### 5.2.3 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.
- 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 활용하면 쉽게 해결할 수 있다.
- 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용될 수 있다. 
	- 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 **데드락**의 원인이 된다.
	-> 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 해결 가능
```SQL
	mysql> SELECT GET_LOCK('mylock1', 10);
	-- // mylcok1에 대한 작업 실행
	mysql> SELECT GET_LOCK('mylock2', 10);
	-- // mylcok2에 대한 작업 실행
	mysql> SELECT RELEASE_ALL_LOCKS();
```
### 5.2.4 메타데이터 락
데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
- 명시적으로 획득/ 해제 할 수 있는 것이 아니다.
- "RENAME TABLE tab_a TO tab_b"와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
```SQL
-- // 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스 용 랭킹 데이터 생성
-- // 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업
-- // 새로 만들어진 랭킹 테이블(rank_new)을 서비스용으로 대체하고자 하는 경우
mysql> RENAME TABLE rank TO rank_backup, rank_new TO rank;
```
- RENAME 작업을 한꺼번에 실행하면 실제 어플리케이션에서는 "Table not found 'rank" 같은 상황을 발생시키지 않고 적용하는 것이 가능하다. 
- 하지만 2개로 나눠서 실행하면 rank 테이블이 존재하지 않는 순간이 생기며, 그 순간에 실행되는 쿼리는 "Table not found rank"d 오류를 발생시킨다.

메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있다. 
- 테이블의 구조를 변경해야 할 요건이 발생했을 때
- MySQL서버의 Online DDL을 이용해 변경할 수 있다.
	- 문제점
		- 언두 로그의 증가, Online DDL 버퍼의 크기
		- MySQL 서버의 DDL은 단일 스레드로 작동하기 때문에 상당히 많은 시간이 소모될 것이다.
	-> 새로운 구조의 테이블을 생성하고 최근의 데이터까지는 프라이머리 키인 id 값을 범위별로 나눠, 여러 개의 스레드로 빠르게 복사한다.
	- 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행할 수 있다. 
	- 남은 데이터를 복사하는 시간 동안은 테이블의 잠금으로 인해 INSERT를 할 수 없게 된다. 

### 5.3 InnoDB 스토리지 엔진 잠금
InnoDB 스토리지 엔진은 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
-> 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 
### 5.3.1 InnoDB 스토리지 엔진의 잠금
잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없다. 
<img width="400" alt="image" src="https://github.com/user-attachments/assets/91d4ca8c-44cf-40c8-a164-1e92157db52f">
- 레고드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.
### 5.3.1.1 레코드 락
레코드 자체만을 잠그는 것
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 인덱스가 하나도 없는 테이블인 경우, 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
### 5.3.1.2 갭 락
 레고드와 레코드 사이의 간격을 잠그는 락
 - 레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT 되는 것을 제어한다.
### 5.3.1.3 넥스트 키락 ??
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- STATEMENT 포맷의 바이너리 로그를 사용 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용한다.
	- 변경을 위해 검색하는 레코드에서는 넥스트 키 락 방식으로 잠금이 걸린다
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
-> 넥스트 키 락과 갭 락으로 데드락이 발생하거나, 다른 트랜잭션을 기다리게 하는 일이 자주 발생한다. 바이너리 로그 포맷을 ROW형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 5.3.1.4 자동 증가 락
AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.
-> InnoDB 스토리지 엔젠에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.

- INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.
- 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다. 
- AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에, 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.
### 5.3.2 인덱스와 잠금
변경할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야한다.
-> UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어진다.
한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 한다.
### 5.3.3 레코드 수준의 잠금 확인 및 해제
MySQL 5.1부터 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.

### 5.4 MySQL의 격리 수준
트랜잭션의 격리 수준(isolation level): 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지말지를 결정하는 것
- READ UNCOMMITED
- READ COMMITED
- REPEATABLE READ
- SERIALIZABLE
! SERIALIZABLE 격리 수준이 아니라면, 격리 수준이 높아진다고 크게 성능의 개선이나 저하는 발생하지 않는다.

<img width="615" alt="image" src="https://github.com/user-attachments/assets/a679cc92-e80c-4ff2-b1d0-5b59303782e3">
InnoDB에서는 독특한 특성 때문에 REPEATABLE READ 격리 수준에서도 PHANTOM READ가 발생하지 않는다.
	! Phantom READ: 한 개의 Transaction에서 같은 조건으로 2번 읽었는데, 2번의 결과가 다른 현상
<img width="500" alt="image" src="https://github.com/user-attachments/assets/0808bbcc-f61a-41b1-9f8b-a8240f71359f">
### 5.4.1 READ UNCOMMITED
각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다. \
<img width="354" alt="image" src="https://github.com/user-attachments/assets/3c5bb7a0-2804-4506-882d-50e7a9294b31">
사용자 B는 사용자 A가 INSERT한 사원의 정보를 커밋되지 않는 상태에서도 조회할 수 있다. 
문제점: 사용자 A가 처리 도중 알 수 없는 문제가 발생해 INSERT된 내용을 롤백한다고 해도, 사용자 B는 정상적인 데이터라 생각하고 계혹 처리할 것이다.
-> 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데, 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드(**Dirty read**)라 한다.
- 더티 리드가 허용되는 격리 수준이 READ UNCOMMITED다.
- 정합성에 문제가 많은 격리 수준이다.
! MySQL을 사용한다면 최소한 READ UNCOMMITED 이상의 격리 수준을 사용할 것을 권장한다.
### 5.4.2 READ COMMITED
어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
<img width="354" alt="image" src="https://github.com/user-attachments/assets/8a273e2e-4b96-40d4-8ac5-899545d66e8f">
이전 값이 언두 영역으로 백업된다. 사용자 A가 커밋을 수행하기 전에 사용자 B가 해당 데이터를 조회하면, 테이블이 아니라 언두 영역에 백업된 레코드를 가져온다.

- READ COMMITED 격리 수준에서도 NON-REPEATABLE READ라는 부정합의 문제가 있다.
<img width="377" alt="image" src="https://github.com/user-attachments/assets/e2be56f7-2cbb-4f19-877b-04ef747a1f56">
- 사용자 B가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결가를 가져와야 한다는 REPEATABLE READ 정합성에 어긋난다.
-> 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.
### 5.4.3 REPEATABLE READ
InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 
- NON-REPEATABLE READ 부정합이 발생하지 않는다.
- InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
- MVCC를 이용해 동일 트랜잭션 내에서 동일한 결과를 보여줄 수 있게 보장한다.
	-> REPEATABLE READ와 READ COMMITED의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.
<img width="401" alt="image" src="https://github.com/user-attachments/assets/3d1e3eff-2174-4d60-aeec-36c4b2d30d28">
InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜재겻의 번호가 포함돼 있다.
- REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터를 삭제할 수 없다.
- 사용자 B는 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 10보다 작은 트랜잭션 번호에서 변경한 것만 보게 된다.

REPEATABLE READ 격리 수준에서도 부정합이 발생할 수 있다.
<img width="402" alt="image" src="https://github.com/user-attachments/assets/a1b08e6b-f8f8-4293-ad16-f5a64426ac82">
- 사용자 B가 실행하는 두 번의 SELECT..FOR UPDATE 쿼리 결과는 서로 다르다. 
	-> 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 **PHANTOM READ**라고 한다.
- SELECT..FOR UPDATE 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 
	-> SELECT...FOR UPDATE나 SELECT---LOCK IN SHARE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 되는 것이다.
### 5.4.4 SERIALIZABLE
가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
- 동시 처리 성능이 다른 트랜잭션 격리 수준보다 떨어진다.
InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다.
	-> Non-locking consistent read(잠금이 필요없는 일관된 읽기)
- 트랜잭션 격리 수준이 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금을 획득해야 한다.
	-> 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
	-> PHANTOM READ 문제가 발생하지 않는다
!InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없어 보인다.