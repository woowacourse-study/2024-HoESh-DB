# OT

- **트랜잭션**
    - 작업의 완전성을 보장해 주는 것
    - 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구
- **트랜잭션 vs 잠금(Lock)**
    - 잠금: 동시성을 제어하기 위한 기능
    - 트랜잭션: 데이터의 정합성을 보장하기 위한 기능
    
> 💡 **정합성**
> 
>    어떤 데이터들이 값이 서로 일치하는 상태
    
- **격리 수준**
    - 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# 5.1 트랜잭션

## 5.1.1 MySQL에서의 트랜잭션

## 5.1.2 주의사항

- 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.

# 5.2 MySQL 엔진의 잠금

## 5.2.1 글로벌 락

- `FLUSH TABLES WITH READ LOCK` 명령으로 획득
- MySql 서버 전체에 영향을 미침(테이블이나 데이터베이스가 달라도 영향 미침)
- `SELECT` 를 제외한 대부분의 DDL, DML 문장을 글로벌 락이 해제될 때까지 대기 상태로 남김
- **백업 락**
    - MySQL 8.0부터 InnoDB가 기본 스토리지 엔진으로 채택되면서 생긴 가벼운 글로벌 락
    - 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없음
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - `REPAIR TABLE` 과 `OPTIMIZE TABLE` 명령
        - 사용자 관리 및 비밀번호 변경
- 추가 학습 키워드
    - 백업(레플리카 서버)

## 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금
- 명시적으로 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블의 락 획득 가능
- `UNLOCK TABLES` 명령으로 잠금 반납(해제)
- 묵시적으로 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공
    - 따라서 DDL의 경우에만 영향을 미침

## 5.2.3 네임드 락

- `GET_LOVCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정
- 잠금의 대상이 테이블이나 레코드 또는 `AUTO_INCREMENT` 와 같은 데이터베이스 객체가 아니다.
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용
    - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 해결 가능…?

## 5.2.4 메타데이터 락

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득(명시적 X)

# 5.3 InnoDB 스토리지 엔진 잠금

## 5.3.1 InnoDB 스토리지 엔진의 잠금

- **레코드 락**
    - 인덱스의 레코드를 잠금(다른 상용 DBMS의 레코드 락과 차이점)
    - 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서 레코드 락을 건다.
- **갭 락**
    - 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- **넥스트 키 락**
    - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- **자동 증가 락**
    - `AUTO_INCREMENT` 칼럼이 사용된 테이블에 거는 잠금(테이블 수준)
    - `INSERT` 나 `REPLACE` 와 같은 새로운 레코드를 저장하는 쿼리에서만 필요

## 5.3.2 인덱스와 잠금

- 인덱스가 하나도 없는 경우 테이블을 풀 스캔하기 때문에 테이블의 모든 레코드를 잠금
    - 인덱스 설계가 중요한 이유

## 5.3.3 레코드 수준의 잠금 확인 및 해제

- `performance_schema` 의 `data_locks` 테이블과 `data_lock_waits` 테이블을 조인해서 잠금 대기 순서 확인 가능
- `KILL` 명령어로 스레드 강제 종료

# 5.4 MySQL의 격리 수준

|  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 없음 | 발생 | 발생 |
| REPEATABlE READ | 없음 | 없음 | 발생
(InnoDB는 없음) |
| SERIALIZABLE | 없음 | 없음 | 없음 |

## 5.4.1 READ UNCOMMITTED

- 각 트랜잭션의 변경 내용이 `COMMIT` 이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 보인다.
- **더티 리드**
    - 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 권장되지 않음

## 5.4.2 READ COMMITTED

- 더티 리드 X
- 어떤 트랜잭션에서 데이터를 변경했더라도 `COMMIT` 이 완료된 데이터만 다른 트랜잭션에서 조회 가능
    - `COMMIT` 전에 다른 트랜잭션에서 데이터를 조회하면 언두 로그 데이터 반환
- `NON-REPEATABLE READ` 라는 부정합의 문제 존재
- `REPEATABLE READ` 정합성
    - 하나의 트랜잭션 내에서 똑같은 `SELECT` 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다.

## 5.4.3 REPEATABLE READ

- `NON-REPEATABLE READ` 라는 부정합의 문제 발생 X
- `READ COMMITTED` 와의 차이점
    - 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐
    - `REPEATABLE READ` 격리 수준에선 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.

## 5.4.4 SERIALIZABLE

- 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 한다.
- InnoDB에선 사용할 필요성 X
- **PHANTOM READ**
    - 한 개의 Transaction 에서 같은 조건으로 2번 읽었는데 2 번의 결과가 다른 현상.
        - `SERIALIZABLE` 격리 수준에선 발생 X
