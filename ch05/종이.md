책에서 나온 내용 + 궁금한 거 정리한 내용입니다

# 5장 트랜잭션

5장은 크게 트랜잭션, 락, 격리수준 세가지 파트로 나뉜다.

---

## 5.1 트랜잭션이 뭘까?

금융권에서도 사용되는 용어다. 금융권에서 financial transaction이란  ”현금을 **주고 받는 거래”를 뜻한다.**

위키피디아에 따르면 컴퓨터 과학에서 뜻하는 transaction은 

- [Transaction processing](https://en.wikipedia.org/wiki/Transaction_processing), information processing that is divided into individual, indivisible operations
- [Database transaction](https://en.wikipedia.org/wiki/Database_transaction), a unit of work performed within a database management system
- [Atomic transaction](https://en.wikipedia.org/wiki/Atomic_transaction), a series of database operations such that either all occur, or nothing occurs

위 세가지가 있다. 

1. 트랜잭션 처리(더 이상 쪼갤 수 없는 작업으로 나누는 작업 처리) 

2. 디비 트랜잭션(DBMS에서 사용되는 **작업의 단위**) 

3. 원자적 트랜잭션 ([처리되거나 / 처리되지 않는] 두 가지 상태만 갖는 일련된 디비의 작업)

책에서는 트랜잭션의 존재 이유를 작업의 완전성, 정합성을 맞추기 위함이라고 설명하고 있다.

정리해보면 트랜잭션이란 작업의 최소 단위이며, 이 작업을 실행한 후, 결과는 (처리 했음(1), 처리하지 못했음(0)) 두 가지 상태 중 하나로 나오도록 **정합성, 완전성을** 보장해주는 논리적 작업 단위다.

데이터 정합성이란?

- 데이터 정합성(Data Consistency): 어떤 데이터값들이 서로 일치하는 상태

이 트랜잭션이라는 ‘거래’를 통해서 작업을 하면 항상 보장된 결과(처리했음, 처리하지 못햇음)를 예상할 수 있으니 데이터를 다루기에 더 유리해지지 않을까?

MyISAM이나 메모리 스토리지 엔진은 트랜잭션을 지원하지 않는다. 아무래도 작업을 할 때 트랜잭션이라는 추가적인 작업을 하면 속도가 느려지겠지? 그래서 트랜잭션이라는 것을 할 필요성을 느끼지 못하는 사람들이 있었다고 한다.

## MyISAM스토리지 와 INNODB 스토리지의 작업 처리 비교

책에서는 duplicated key 예제를 사용해 두 스토리지의 작업 처리를 비교하고 있다.

MyISAM에서 값을 Insert하다가 에러가 발생하면 부분적 업데이트(Partial update)가 발생한다.

1. pk = 3인 데이터를 Insert한다.
2. pk = 1, pk = 2, pk =3인 데이터를 차례대로 Insert한다.
3. pk=3인 데이터를 Insert할 때 예외가 발생한다.
4. 데이터를 조회하면 pk=1, pk=2인 데이터는 저장되어 있다. (partial update)

InnoDB스토리지는 당연히 트랜잭션을 사용하기 때문에 pk=1, pk=2인 데이터가 저장되지 않는다. 트랜잭션 과정 중에 있기 떄문에 예상치 못한 예외가 발생하면 당연히 rollback 된다. 트랜잭션 도중에 하고 있었던 작업들을 모두 롤백시키고, 트랜잭션을 처리하지 못한 상태가 된다.(근데 문득 궁금한건 서비스 특성에 따라 partial update가 필요한 경우도 있지 않을까? 굳이 저장한 모든 데이터를 모두 롤백을 시키는것도 코스트가 크고, 작업의 기록이 남아있기 때문에 어디서 뭘 하다가 에러가 발생한건지 추적,로깅하는 용도로도 쓰일 수 있지 않을까? 정합성 문제가 있긴 한데 특별한 용도로 쓰일지도?)

## 트랜잭션 설계

트랜잭션의 범위는 최대한 작게 가져가는게 좋다. 트랜잭션 자체가 코스트가 크고, 4장에서 mysql 아키텍처를 배울 때도 트랜잭션을 오랫동안 열어두면 언두로그의 용량이 계속 커져 성능상 좋지 않다고 했었던거 같다. 

특히 웹서버, 메일, FTP통신 등 외부 자원과 통신해야할 때, 어떻게든 DBMS의 트랜잭션의 범위 내에서 하지 않도록 주의하자. DBMS 트랜잭션 범위 내에 외부 자원과 통신할 때, 외부 자원에 장애가 생가면 곧 DBMS의 장애까지 이어질 수도 있다. ← 특히 주의!!

# 5.2 잠금

트랜잭션(Transaction)이 DBMS에서 작업의 정합성, 완전성을 보장하기 위한 논리적인 작업 단위라면, 잠금(Lock)이란 동시성 제어를 위한 것이다. 여러 커넥션이 같은 자원을 요청할 경우, 잠금이 되어있다면 하나의 커넥션만, 순차적으로 접근할 수 있도록 제어해주는 기술이다.

잠금은 크게 MySQL 엔진 잠금과 InnoDB 스토리지 잠금으로 나눠볼 수 있다.

### MySql 엔진 잠금

MySql엔진 잠금은 스토리지 엔진을 제외한 모든 부분이라고 보면 된다.

MySql엔진 잠금은 모든 스토리지에 대해 영향을 미치지만, 스토리지 엔진 잠금은 서로간에 영향을 끼치지 않는다.

락에도 여러 종류가 있는데, 글로벌 락, 테이블 락, 네임드 락, 메타 데이터락을 순서대로 알아보자

### 글로벌 락

```markdown
FLUSH TABLES WITH READ LOCK
```

가장 범위가 넓다. mysql서버의 전체에 영향을 끼친다. 글로벌 락의 범위는 MySQL 서버 전체이므로 테이블이나 데이터베이스가 다르더라도 영향을 받는다.

트랜잭션을 지원하지 않는 MyISAM이나 메모리 스토리 엔진을 사용하고 있으면서 mysqldump를 백업받아야 할 때 주로 사용된다.

- 161페이지 오탈자 발견! (주의 밑에, mysql이 업그레이드(되)면서??)

전체 데이터의 변경 작업을 멈추어야 할 때 적용할 수 있지만 Mysql 8.0부터 InnoDB 스토리지 엔진이 기본으로 채택되면서 이제는 기본으로 트랜잭션을 지원하므로 그럴 필요가 없고, 글로벌 락은 서버에 큰 영향을 미치므로 사용하지 않는 것이 좋다.

백업툴이 도입되면서 백업락이 생겼다. 특정 세션에서 백업락 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없다. 그러나 일반적인 테이블의 데이터 변경은 허용된다.

### 테이블 락

개별 테이블 단위 잠금 기능이다. 명시적, 묵시적 락이 있는데(명시적 락은 명시적으로 해제 가능) 명시적 락은 특별한 경우가 아니면 잘 쓰이지 않는다. 묵시적 락은 MyISAM이나 MEMORY테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. 변경할때 잠금을 걸어놓고 변경 즉시 해제한다. InnoDB의 경우는 스토리지 차원에서 레코드 기반 잠금을 제공해서 테이블 락이 걸리지 않는다. 정확히는 DML은 영향을 안끼치고 DDL의 경우만 영향을 미친다.

### 네임드 락

`GET_LOCK` 함수를 통해 임의의 문자열을 잠금 수 있다. 특이한 점은 잠그는 대상이 테이블이나레코드 또는 데이터베이스 객체가 아니다. 이것도 잘 쓰이지는 않는다고 한다.(잘 쓰이는건 언제 나오지?) 여러 클라이언트가 어떤 정보를 동기화하는 것처럼 상호 동기화 처리해야 할 때 요긴하다. 배치처럼 한번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 되는데 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸어 해결해볼 수도 있다.

### 메타 데이터 락

데이터 베이스(테이블이나 뷰)의 이름이나 구조를 변경하는 경우에 획득할 수 있다. 메타 데이터 락은 명시적으로 획득이 불가능하다(다 알아서 해주나보다). `rename`같은 경우 `rename table a to b` 에서 a랑b 둘 다 잠금을 건다. 메타 데이터를 변경할 때 락이 걸린다는 걸 알아 두면 좋을 거 같다.

## 5.3 MySql 스토리지 잠금

레코드 기반 잠금 기능을 제공한다. 락 에스컬레이션은 없다. InnoDB에서는 **레코드 끼리의 간격을 잠그는 갭 락**이라는 것도 있다.

### **레코드 락**

레코드를 잠그는 것으로 다른 상용 DBMS의 레코드 락이랑 동일한 역할을 한다. 한가지 차이는 InnoDB에서는 **인덱스의 레코드를 잠금다.** 인덱스가 없어도, 자동 생성된 클러스터 인덱스를 이용해서 잠금을 실행한다. 보조 인덱스를 이용한 변경 -> 넥스트 키 락이나 갭 락 사용한다. PK나 UK에 의한 변경 작업에서는 레코드 자체에만 락을 건다.

### **갭 락**

레코드와 바로 인접한 레코드 사이의 간격만들 잠근다. 이거 역할은 저 레코드 사이에 새로운 레코드가 생성되는거를 제어하는것이다. 넥스트 키 락의 일부로 사용된다.

### **넥스트 키 락**

레코드락과 갭락을 합친 것이라고 보면 된다. InnoDB의 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장한다.

### **자동 증가 락**

mySQL에서는 자동증가하는 숫자값을 추출하기 위해 `AUTOO_INCREMENT` 속성을 제공한다. 여러 레코드가 insert되면 서로 중복없이 저장된 순서대로 증가해야 한다.이 때 사용하는 것이 자동 증가 락이고 하는 테이블 수준 잠금을 사용한다. 

자동 증가 값이 한번 증가하면 다시 줄어들지 않는 이유는? 자동 증가 락의 잠금을 최소화시키기 위해

### **인덱스와 잠금**

InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있다. InnoDB의 잠금은 레코드가 아니라 **인덱스를 잠그는 방식으로 처리**된다. 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 건다. (테코톡에 잘 설명이 되어있다) 인덱스 설계가 중요한 이유이기도 하다.

### **레코드 수준의 잠금 확인 및 해제**

 테이블 수준 잠금보다 InnoDB의 레코드 수준 잠금 복잡하다. 레코드에 잠금이 오래 되어 있어도 발견하기가 어렵다. 요즘은 조회가 가능하다.

## 5.4 격리 수준

| Dirty Read | Non-Repeatable Read | Phantom Read |
| --- | --- | --- |
| Read Uncommitted | 발생 | 발생 |
| Read Committed | 없음 | 발생 |
| Repeatable Read | 없음 | 없음 |
| Serializable | 없음 | 없음 |

### **Read Uncommitted**

- 각 트랜잭션 변경 내용이 commit이나 rollback여부와 관계 없이 보임
- Dirty Read 발생 가능
    - 데이터가 롤백되었는데 그게 마치 있는 것처럼 보이는 현상
- 참고로 이 Read Uncommitted는 정합성에 많은 문제가 있어 아예 격리 수준으로 인정하지도 않는다고 한다.(그럴만함)

### **Read Committed**

- 오라클 기본 격리수준 + 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 이거는 Commit 완료된 데이터만 조회 가능하다.
- Non-Repeatable Read 발생 가능
    - 한 트랜잭션 내에서 다른 트랜잭션의 커밋 시점에 의해 다른 결과를 가져오게 된다.
    - 즉 Repeatable Read 정합성에 어긋난다.
    - 금전처리처럼 하나의 트랜잭션에서 동일 데이터를 여러번 읽고 작업하는 경우 문제가 된다.

### **Repeatable Read**

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용
- 바이너리 로그를 가진 MySQL서버에서는 최소 Repeatable Read 격리 수준 이상을 사용해야 한다.
- 이거는 Non-Repeatable Read 부정합이 발생하지 않음
- 트랜잭션 Rollback에 대비해서 언두로그 백업하고 그 데이터를 이용해 동일 트랜잭션 내에서는 동일한 데이터를 보여준다.
- 트랜잭션이 각각의 트랜잭션 번호를 가져서(이게 순차적 증가임) 언두 영역 레코드에는 이 번호가 저장되어 있고 그거를 통해 데이터를 가져오면 되는것
- 이것도 근데 Phantom Read 현상 발생 가능
    - `select for update`같은 경우는 select대상 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없다.
    - 그래서 이거는 언두영역의 변경 전 데이터가 아니라 현재 레코드의 값을 가져오는것

### **Serializable**

- 가장 단순하고 엄격하다.
- 동시 처리 성능도 떨어짐
- 읽기 잠금에도 공유잠금을 걸어주는거
    - 참고로 InnoDB에서 "Non-locking consistent read(잠금이 필요없는 일관된 읽기)"라는 말이 존재하는데, 얘는 본래 보통은 읽기에 잠금을 걸지 않는다는 것이다.
        - 그래서 이거 락 걸어주면 성능이 떨어진다.
- 근데 InnoDB스토리지 엔진에서는 갭락과 넥스트 키 락 덕분에 Repeatable Read에서도 Phantom Read가 발생하지 않는다(select for update, select for share처럼 잠금을 동반한 select는 예외)
    - 지금 트랜잭션에서 읽는 대상이 된 인덱스에 대해서는 데이터의 입력이 불가능하므로...
    - 그러니까 그냥 InnoDB에서는 Repeatable Read를 쓰면 되는데 이걸 굳이 쓸 필요는 없다는 것
