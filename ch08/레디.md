# 인덱스
> 매우 어려운 장이였다.
> 아리까리한 부분도 많았고 ps할 때 만났던 반가운 친구들도 보았다.
> 쿼리 성능 튜닝을 위해 앞으로 많이 찾아볼 부분일듯

<br>

# 8.1 디스크 읽기 방식

인덱스는 db의 쿼리 튜닝을 위해 꼭 필요한 기능이다.

디스크 읽기 방식에는 랜덤 I/O와 순차 I/O가 있다. db 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 다수.

## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 하드 디스크 드라이브는 기계식 장치. 병목 현상이 발생
- SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 플래시 메모리를 장착
- 때문에 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 빠르게 데이터를 읽고 쓺 (랜덤 I/O)가 뛰어남
- 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
- 컴퓨터의 메모리 D-Ram 보다는 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠르다.

## 8.1.2 랜덤 I/O와 순차 I/O

- 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜을 요청했다.
- 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 옮기는 단게에서 결정된다.
- 그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다.

# 8.2 인덱스

- DBMS에서 인덱스는 데이터의 저장(Insert, Update, Delete) 성능을 희생하고 그 대신 데이터의 읽기(Select) 속도를 높이는 기능이다.
- 인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary Key)와 보조 키(Secondary Key)로 구분할 수 있다 (키와 인덱스를 같은 의미로 사용)
    - 프라이머리 키: 레코드를 대표하는 칼럼(식별자)의 값으로 만들어진 인덱스, 프라이머리 키는 Null 값을 허용하지 않으며 중복을 허용하지 않는다.
    - 보조 키: 프라이머리 키를 제외한 나머지 모든 인덱스는 보조 키로 분류한다. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데 별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.
    
- 데이터 저장 방식별로 구분할 경우 여러 방법이 있겠지만 대표적으로 B-Tree와 Hash 인덱스가 있다.
    - B-Tree 인덱싱: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘, 균형 트리 형태로 저장하며 리프 노드 뿐만 아니라 모든 노드에 값이 있다.
    - Hash 인덱싱: 칼럼의 값으로 해시값을 계산하여 인덱싱하는 알고리즘, 매우 빠른 검색을 지원하지만, 값을 변형해서 인덱싱하므로 prefix 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때에는 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 사용

# 8.3 B-Tree 인덱스

## 8.3.1 구조 및 특성

- B는 Balanced의 약어
- 최상위 노드 ‘루트 노드(Root node)’, 최하위 노드 ‘리프 노드(Leaf node)’, 그 외의 노드 ‘브랜치 노드(Branch node)’ 형태
- 인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있음
- 항상 insert 순서대로 저장되는 것은 아님. delete 되면 그 빈 공간으로 insert 됨. 때문에 insert 작업만 있다면 insert 순서대로 저장되기는 함
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 대문에 논리적인 주소를 가진다고 볼 수 있음

- MyISAM 테이블에는 레코드 주소를 이용해 바로 레코드에 접근한다.
- 레코드 주소는 생성 옵션에 따라 변경될 수 있는데, 레코드가 테이블에 insert 된 순번이거나 데이터 파일 내의 위치(Offset)다.
- InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가

- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 찾고 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장한다.
- 리프 노드가 꽉 찬다면 리프 노드를 분리하는 작업을 한다. (상위 노드까지 건들이는 작업)

### 8.3.2.2 인덱스 키 삭제

- 삭제 작업은 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료
- 삭제 마킹된 공간은 그대로 방치되거나 재활용할 수 있다.
- 이 마킹 작업 역시 디스크 쓰기가 필요하므로 디스크 I/O가 필요한 작업이다.
- MySQL 5.5 이상 버전에서는 이 작업 또한 버퍼링되어 지연 처리할 수 있다.

### 8.3.2.3 인덱스 키 변경

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 B-Tree의 키 값만 변경하는 것은 불가능
- 우선 변경하고자 하는 키를 삭제하고 다시 새로운 키 값을 추가하는 형태로 처리
- InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리

### 8.3.2.4 인덱스 키 검색

- 인덱스를 사용하는 이유는 바로 검색을 효율적으로 하기 위함
- 검색 작업은 루트 노드부터 시작하여 브랜치 노드를 거쳐 리프 노드까지 이동하면서 비교 작업을 수행(트리 탐색)
- 100 % 일치, 값의 앞부분(Left-most Part), 부등호(<, >) 비교에서 인덱스를 활용할 수 있지만 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없음
- 또한 키 값에 변형이 가해진 후 비교되는 경우에도 B-Tree의 빠른 검색 기능을 사용할 수 없음

- InnoDB 테이블에서 지원하는 레코드 락이나 넥스트 키랍이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수

### 8.3.3.1 인덱스 키 값의 크기

- 페이지(Page) 혹은 블록(Block)이 InnoDB 스토리지 엔진에서 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위이며, 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- 인덱스도 역시 페이지 단위로 관리된다.
- B-Tree 에서 자식 노드의 개수는 인덱스 페이지 크기와 키 값의 크기에 따라 결정된다.

- 페이지 크기는 기본 16KB이며 innodb_page_size 시스템 변수를 통해 4KB ~ 64KB 사이의 값을 설정할 수 있다.
- 페이지의 크기를 16KB로 가정하고, 인덱스의 키가 16B라고 가정하고, 자식 노드 주소 크기가 평균적으로 12B(페이지마다 6B ~ 12B로 다름)라고 가정했을 때, 하나의 인덱스 페이지에 저장될 수 있는 키의 개수는 16 * 1024 / (16 + 12) = 585개 저장할 수 있다.
- 쿼리 레코드가 500개를 읽어야한다면 인덱스 페이지 한번으로 해결할 수 있다.
- 하지만 인덱스의 키의 크기가 두배로 늘어났다고 가정하면 한 페이지에 인덱스 키를 16 * 1024 / (32 + 12) = 372개밖에 저장하지 못하고, 위와 같이 500개를 읽어야 한다면 디스크로 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.
- 인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 제한적이기 때문에 인덱스의 크기가 커질 수록 메모리에 캐시해둘수 있는 레코드 수는 줄어든다.

### 8.3.3.2 B-Tree 깊이

- 인덱스의 B-Tree 깊이가 3인 경우
    - 키 값이 16바이트라면 최대 2억 (585 * 585 * 585)개 정도의 키 값을 저장 가능
    - 키 값이 32바이트라면 최대 5천만(372 * 372 * 372)개 정도의 키 값을 저장 가능
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 때문에 B-Tree 깊이가 깊어져 디스크 읽기 작업이 더 소요된다.
- 결론 인덱스 키 값의 크기를 가능한 작게 만들자.

### 8.3.3.3 선택도 Selectivity 혹은 (기수성 Cardinality)

- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
- 인덱스 키 값 가운데 중복된 값이 많아지면 기수성은 낮아지고 선택도 또한 떨어진다.
- 인덱스는 선택도가 높을수록 검색대상이 줄어들어 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많기에 적절하게 인덱스를 설계하자

**예시**

country 칼럼과 city 칼럼이 포함된 tb_test 테이블에 레코드 건수가 1만 건 존재. 그리고 country 칼럼으로만 인덱스가 생성된 상태에서 아래 케이스를 비교해보자.

`select * from tb_test where country = 'KOREA' and city = 'SEOUL';` 

- 케이스 A: country 칼럼의 유니크한 값의 개수가 10개
    
    → 1건의 레코드를 위해 쓸모없는 999개의 레코드를 더 읽기에 비효율적
    
- 케이스 B: country 칼럼의 유니크한 값의 개수가 1,000개
    
    → 1건의 레코드를 위해 쓸모없는 9건의 레코드를 더 읽기에 위 케이스보다 효율적
    

### 8.3.3.4 읽어야 하는 레코드의 건수

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 레코드를 읽는 것보다 높은 비용이 드는 작업
- 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업으로 예측
- 옵티마이저가 인덱스를 통해 읽어야할 레코드의 건수를 전체 테이블 레코드의 20~25%를 넘어선다면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

- 가장 대표적인 접근 방식이며 가장 빠르다.
- 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- `select * from employees where first_name between 'Ebbe' and 'Gad'` 와 같은 쿼리가 주어졌을 때, 인덱스 레인지 스캔을 사용한다면 ‘Ebbe’를 루트 노드에서 부터 비교를 시작해 브랜치 노드를 거치고 리프 노드까지 찾아 들어가 레코드의 시작점을 찾고 그 이후부터 리프 노드의 레코드를 순서대로 읽는 방식이다 (B-Tree 가 맞나…? B+Tree 아닌가)
- `show status like 'Handler_%';` 명령어를 통해 인덱스 스캔 과정이 얼마나 수행됐는지 확인할 수 있다.
    - Handler_read_key: index seek(인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는 과정)가 실행된 횟수
    - Handler_read_next, Handler_read_prev: index scan(index seek 후 필요한 만큼의 인덱스를 차례대로 읽는 과정)으로 읽은 레코드 건수를 의미한다.
        - next는 인덱스 정순으로 읽은 건수이며, prev는 인덱스 역순으로 읽은 레코드 건수다.
    - Handler_read_first, Handler_read_last: 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수를 의미하는데, 이 둘은 MIN(), MAX()와 같이 제일 큰 값 또는 제일 작은 값만 읽는 경우 증가하는 상태 값

### 8.3.4.2 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 탐색하는 방법
- 인덱스는 (A, B, C) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우 사용
- 일반적으로 인덱스의 크기가 테이블의 크기보다 작으므로 직접 테이블을 전부 읽어야하는 경우 인덱스만 읽는 것이 효율적
- 인덱스 레인지 스캔보다 빠르지는 않지만 테이블 풀 스캔보다는 효율적
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식을 사용

### 8.3.4.3 루스 인덱스 스캔

- 오라클의 “인덱스 스킵 스캔”과 작동 방식이 비슷
- 인덱스 레인지 스캔과 인덱스 풀 스캔은 루스 인덱스 스캔과 상반된다는 의미에서 타이트 인덱스 스캔으로 분류한다.
- 레인지 스캔과 비슷하게 작동하지만 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어간다.
- 일반적으로 `GROUP BY`, `MAX()`, `MIN()` 함수에 대해 최적화를 하는 경우에 사용된다.

### 8.3.4.4 인덱스 스킵 스캔

- 데이터베이스 서버에서 인덱스의 핵심은 값이 정렬되어 있다는 것이기에 인덱스를 구성하는 칼럼의 순서가 매우 중요

**예시**

인덱스 (gender, birth_date)

- `select * from employees where birth_date >= '1965-02-01;'`
    - 인덱스를 사용하지 못하는 쿼리

- `select * from employees where gender='M' and birth_date >= '1965-02-01';`
    - 인덱스를 사용할 수 있는 쿼리

- 첫번째 쿼리 같은 경우 gender 칼럼에 대한 비교 조건이 없었기에 인덱스를 사용할 수가 없었는데, MySQL 8.0 부터 옵티마이져가 gender 칼럼을 건너 뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해줌
- 인덱스 스킵 스캔 옵션을 제거한다면 인덱스 풀 스캔을 사용하거나 풀 테이블 스캔을 사용해야 한다.
- 8.0 이전에는 루스 인덱스 스캔을 활용하여 인덱스 스킵 스캔과 비슷한 최적화를 수행했지만 이는 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능했다.

- `SELECT gender, birth_date FROM employees WHERE birth_date ≥ ‘1965-02-01’`
- 위 쿼리를 인덱스 스킵 스캔을 사용한다면 gender 칼럼에서 유니크한 값을 모두 조회해 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리
    - `SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date >= ‘1965-02-01’`
    - `SELECT gender, birth_date FROM employees WHERE gender='F' AND birth_date >= ‘1965-02-01’`
- 인덱스 스킵 스캔에는 단점이 존재한다.
    - where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
        - 레인지 스캔 시작지점을 검색하는 작업이 많이 필요해져 쿼리의 성능이 매우 떨어짐
    - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함
        - gender, birth_date 만 조회하는게 아니라 모든 칼럼을 조회한다면 풀 테이블 스캔을 실행하는 게 나음

## 8.3.5 다중 칼럼(Multi-column)

- 서비스용 데이터베이스에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다.
- 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하다.

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 어느 방향에서 읽을지는 옵티마이져가 실시간으로 만들어내는 실행 계획에 따라 결정된다

### 8.3.6.1 인덱스의 정렬

- 8.0 버전부터는 오름차순 및 내림차순의 정렬 순서를 혼합한 인덱스를 생성할 수 있다.
    - ex) `create index ix_teamname_userscore on employees (team_name asc, user_score desc);`

- 인덱스 정순 스캔과 인덱스 역순 스캔 중 인덱스 정순 스캔이 더 빠른데 InnoDB의 내부적인 이유때문이다.
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE 조건이나 GROUP BY, 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.

### 8.3.7.1 비교 조건의 종류와 효율성

- `select * from dept_emp where dept_no='d002' and emp_no >= 10114;`
- 케이스 A : INDEX (dept_no, emp_no)
    - dept_no = ‘d002’ and emp_no ≥ 10114인 레코드를 찾고 dept_no가 ‘d002’가 아닐때까지 읽기 (꽤 효율적)
- 케이스 B : INDEX (emp_no, dept_no)
    - emp_no ≥ 10114 and dept_no=’d002’ 인 레코드를 찾고 그 모든 레코드에 대해 dept_no가 ‘d002’인지 비교하는 과정을 거쳐야 한다. (비효율적)

- 케이스 A 인덱스에서 두 조건과 같이 작업의 범위를 결정하는 조건을 `작업 범위 결정 조건`이라고 하고, 케이스 B 인덱스의 dept_no=’d002’ 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 `필터링 조건` 또는 `체크 조건`이라고 표현한다.
- 작업 범위 결정 조건이 많으면 많을 수록 쿼리의 처리 성능을 높이지만 체크 조건이 많다고 해서 쿼리의 처리 성능을 높이지 못할 뿐더러 오히려 쿼리 실행을 더 느리게 만들때도 있다.

### 8.3.7.3 가용성과 효율성 판단

- B-Tree 인덱스의 특성상 다음 조건에서는 작업 범위 결정 조건으로 인덱스를 사용할 수 없다.
- NOT-EQUAL로 비교된 경우 (`< >`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`)
    - WHERE column < 'N'
    - WHERE column NOT IN (10, 11, 12)
    - WHERE column IS NOT NULL
- LIKE '%??' 앞부분이 아닌 뒷부분 일치 형태로 문자열 패턴이 비교된 경우
    - WHERE column LIKE '%승환'
    - WHERE column LIKE '_승환'
    - WHERE column LIKE '%승%'
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
    - WHERE SUBSTRING(column, 1, 1) = 'X'
    - WHERE DAYOFMONTH(column) = 1
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - WHERE column = deterministic_function()
- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
    - WHERE char_column = 10
- 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column

- 다른 일반적인 DBMS에서는 Null 값이 인덱스에 저장되지 않지만 MySQL에서는 Null 값도 인덱스에 저장 가능

`INDEX ix_test (column_1, column_2, column_3, .. column_n)` 

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)
    - column_1 ~ colummn_(i-1) 칼럼까지 동등 비교 형태
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
        - 동등 비교
        - 크다 작다 형태
        - LIKE로 죄측 일치 패턴

# 8.8 클러스터링 인덱스

- 클러스터링이란 여러 개를 하나로 묶는다는 의미로 사용
- MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현
- InnoDB 스토리지 엔진에서만 지원

## 8.8.1 클러스터링 인덱스

- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 함
- B-Tree와 구조가 비슷하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와 달리 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있음
- 프라이머리 키가 없는 InnoDB 테이블은 InnoDB가 다음 우선순위대로 프라이머리 키를 대체할 칼럼을 선택
    1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
    2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
    3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼의 내부적으로 추가한 후, 클러스터링 키로 선택
        1. 자동으로 추카된 프라이머리 키는 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없다. 고로 InnoDB 테이블에서 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 혜택이므로 가능한 프라이머리 키를 명시적으로 생성하자.

## 8.8.2 세컨더리 인덱스에 미치는 영향

- MyISAM 이나 MEMORY 테이블 같은 클러스터링되지 않은 테이블은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않음
    - 실제 레코드가 저장된 주소가 ROWID 역할을 함
    - 프라이머리 키나 세컨더리 인덱스가 ROWID를 이용해 실제 데이터 레코드를 찾을 수 있다.
- InnoDB는 레코드가 위치를 이동할 수 있음
    - InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면, 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스의 저장된 주소값을 변경해야 할 것임
    - 때문에 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있음
    - 세컨더리 인덱스를 검색해 레코드의 프라이머리 키 값을 확인 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

## 8.8.3 클러스터링 인덱스의 장점과 단점

**장점**

- 프라이머리 키로 검색할 때 처리 성능이 매루 빠름(특히 범위 검색)
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기에 처리될 수 있는 경우가 많음

**단점**

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE하고, INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

## 8.8.4 클러스터링 테이블 사용 시 주의사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

- 모든 세컨더리 인덱스가 프라이머리 키 값을 포함하기 때문에 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 커짐

### 8.8.4.2 프라이머리 키는 AUTO_INCREMENT보다는 업무적인 칼럼으로 생성

- InnoDB의 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정
- 대부분 검색에서 빈번히 사용되므로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋음

### 8.8.4.3 프라이머리 키는 반드시 명시할 것

- AUTO_INCREMENT를 사용해서라도 프라이머리 키를 생성하기
- InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 칼럼을 추가하는데, 이를 사용자가 접근(사용)할 수 없다.

### AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

- 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 떄가 가끔 있다.
- 프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋음
- 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고 이를 프라이머리 키로 설정
- 로그 테이블과 같이 조회보다 INSERT 위주의 테이블은 인조식별자가 성능향상에 유리

# 8.9 유니크 인덱스

- 유니크 인덱스는 인덱스라기보다 제약 조건에 가까움
- 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미
- 유니크 인덱스에서 NULL도 저장 가능한데, NULL은 특정 값이 아니므로 2개 이상 저장 가능

## 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 구조상 아무런 차이점 없음
- 읽기에서 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아 느린 것이지 인덱스 자체의 특성 때문에 느린 것이 아님
- 유니크 인덱스는 키 값을 쓸 때 중복 체크를 하는 과정이 필요하기 때문에 세컨더리 인덱스의 쓰기보다 느림
    - 중복 체크에서 읽기 락, 쓰기를 할 때 쓰기 락이 걸려 이 과정에서 데드락이 자주 발생

## 8.9.2 유니크 인덱스 사용 시 주의사항

- 꼭 필요한 경우라면 당연히 생성
- 하지만 성능이 더 좋아질 것으로 생각하고 불필요하게 만드는 것은 좋지 않음

# 8.10 외래키

- InnoDB 스토리지 엔진에서만 생성할 수 있음
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됨
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음
- 외래키 관리에 있는 두 가지 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
    - 외래키과 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
