## 디스크 읽기 방식
- 디스크 I/O는 컴퓨터에서 가장 느린부분이다.
- 메모리와 처리 속도 10만 배 이상의 차이가 난다.
### 하드 디스크 드라이브(HDD) 와 솔리드 스테이트 드라이브(SSD)
- 순차 I/O는 SSD가 조금 빠르거나 비슷하다.
- 랜덤 I/O는 SSD가 훨씬 빠르다.
- DBMS는 랜덤 I/O가 많아 SSD가 더 좋다.
### 랜덤 I/O와 순차 I/O
- 순차 I/O는 시스템 콜 1번
- 랜덤 I/O는 시스템 콜 여러번
- [!] 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하고 풀 테이블 스캔은 순차 I/O를 사용한다. 그래서 인덱스를 사용하지 않는 것이 더 유리할 수 있다.
## 인덱스
- 인덱스를 기준으로 정렬한다.
- 저장 성능을 희생하고 읽기 속도를 높이는 기능이다.
- 인덱스의 역할
	- 프라이머리 키
	- 보조키
- 유니크 인덱스와 유니크 하지 않은 인덱스는 옵티마이저에게 상당히 중요한 문제다.
	- 1개만 찾고 더 찾지 않아도 되기 때문이다.
## B-Tree 인덱스
- 트리 구조로 루트노드, 리프노드, 브랜치 노드로 구성된다.
- 인덱스의 리프노드는 레코드의 주소값을 가진다.
- InnoDB는 클러스터되어 프라이머리 키 순서로 디스크에 저장된다.
### 인덱스 키 추가 및 삭제
- 추가
	- 저장될 때 저장 위치를 검색한 후 리프 노드에 저장한다.
	- 리프 노드가 꽉 차면 리프 노드를 분리하면서 상위 브랜치도 변경한다.
	- 인덱스에 키를 추가할 수 록 쓰기 시 1.5 정도의 비용이든다.
- 삭제
	- 해당 키 값이 저장된 리프 노드를 찾아 삭제 마크만 하면 된다.
	- 지연 처리 할 수 있다.
- 변경
	- 삭제 + 추가
- 검색
	- 100% 일치하거나 앞부분만 일치하는 경우 인덱스를 이용하여 검색할 수 있다.
	- 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 B-Tree 인덱스를 탈 수 없다.
#### B-Tree 인덱스 사용에 영향을 미치는 요소
- 칼럼의 크기
- 레코드의 건수
- 유니크한 인덱스 키 값의 개수
#### 인덱스 키 값의 크기
- 페이지 : InnoDB 스토리지 엔진이 디스크에 데이터를 저장하는 가장 기본 단위
	- 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
	- 루트, 브랜치, 리프 노드를 구분하는 기준도 페이지 단위
- B-Tree는 자식 노드의 개수가 가변적인 구조다.
	- 자식 노드의 수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
- 인덱스 키 값의 크기가 증가하면 한 페이지에 인덱스 키의 수량이 줄어든다.
	- 인덱스의 크기가 커지면 여러 페이지를 읽어야한다.
	- 인덱스를 캐시해두는 버퍼풀의 크기도 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.
#### B-Tree 깊이
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지에서 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.
- 가능한 인덱스 키 값의 크기를 작게 만드는 것이 좋다.
#### 선택도
- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.
- 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.
#### 읽어야 하는 레코드의 건수
- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식을 처리하는 것이 효율적이다.
- 옵티마이저는 인덱스로 레코드 1건을 읽는 비용이 테이블에서 직접 읽는 것보다 4~5배 비용이 많이 든다고 예측한다.
#### B-Tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
	- 검색해야할 범위가 결정되었을 때 사용하는 방식
	- 1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.
	- 2. 시작 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.
	- 3. 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.
		- 레코드 주소로 랜덤I/O를 통해 데이터 파일을 읽어온다.
	- 쿼리에 따라 3번이 필요없을 수 있다.(커버링 인덱스) ex) count
	- 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스보다 테이블의 데이터를 직접읽는 것이 더 효율적이다.
- 인덱스 풀 스캔
	- 인덱스의 처음부터 끝까지 읽는 방식
	- 인덱스에 명시된 컬럼만으로 조건을 처리하는 경우만 사용된다.
	- 테이블 풀 스캔보다는 효율적이지만 인덱스 레인지 스캔보다 느리다.
	- 인덱스를 효율적으로 사용하지 못한다고 할 수 있다.
- 루스 인덱스 스캔
	- 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태이다.
	- GROUP BY와 MIN 함수 최적화에 일반적으로 사용된다.
		- 인덱스 페이지 1번째만 읽으면 되기 때문이다.
- 인덱스 스킵 스캔
	- WHERE 절에 1번째 인덱스 칼럼이 없지만 수가 적을 때 있다고 가정하고 레인지 스캔 후 스킵을 진행한다.
	- 인덱스가 아닌 다중 컬럼을 조회하면 풀 테이블 스캔을 하게 된다.
### 다중 컬럼 인덱스
- 2개 이상의 칼럼을 포함하는 인덱스
- 인덱스 내에서 칼럼의 순서가 중요하다.
- 뒤에 칼럼은 앞에 칼럼에 의존해서 정렬된다.
###  B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다.
- 인덱스를 어느 방향으로 읽을지 실행 계획에 따라 결정된다.
#### 인덱스의 정렬
- 인덱스의 오름차순, 내림차순 정렬을 지정할 수 있다.
- 오름차순으로 정렬되어 있어도 거꾸로 읽을 수 있다.
- 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수밖에 없다.
	- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
	- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
- 자주 사용되는 정렬 순서대로 인덱스를 생성하여 잠금 병목 현상을 완화할 수 있다.
#### B-Tree  인덱스의 가용성과 효율성
##### 비교 조건의 종류와 효율성
`dept_no='d002' and emp_no >= 10144` 인 상황
인덱스(dept_no, emp_no) : 작업 범위 결정 조건(작업 범위를 한번만 결정해두고 쭉 읽으면 된다.)
인덱스(emp_no, dept_no) : 필터링 조건(emp_no로 범위를 찾고 dept_no로 필터링한다.)
- 작업 범위 결정 조건이 많을 수 록 성능을 높인다.
##### 인덱스의 가용성
- B-Tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다.
- 왼쪽에 더 특수한 조건인 경우가 성능상 좋다.
##### 가용성과 효율성 판단
- 인덱스를 사용할 수 없는 경우
	- NOT-EQUAL : <>, NOT IN, NOT BETWEEN, IS NOT NULL
	- LIKE '%??'
	- 함수나 연산자로 컬럼이 변형된 경우
	- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
	- 데이터 타입이 서로 다른 비교
	- 문자열 데이터 타입의 콜레이션이 다른 경우
- MySQL 은 NULL값도 인덱스에 저장된다.
- INDEX ix_test (col_1, col_2, col_3) 인 경우에 인덱스를 사용하지 못하는 경우
	- col_1의 조건이 없는 경우
	- col_1의 비교 조건이 위에 조건 인 경우

### 전문 검색 인덱스
- B-Tree 인덱스는 칼럼 전체의 값을 인덱스 키로 사용하는 것이 아니라 잘라서 사용한다.
- 전문 검색에는 B-Tree 인덱스를 사용할 수 없다.
#### 인덱스 알고리즘
##### 어근 분석 알고리즘
- 불용어 처리
	- 검색에서 별 가치가 없는 단어를 모두 필터링 해서 제거하는 작업을 의미한다.
	- 사용자가 직접 정의해서 사용하는 경우가 많다.
- 어근 분석
	- 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
	- 문장을 해채해서 각 단어의 품사를 식별할 수 있는 문장의 구조 인식이 필요하다.
	- 샘플을 이용해 학습하는 과정이 필요하다.
- n-gram 알고리즘
	- 키워드를 검색해내기 위한 인덱싱 알고리즘
	- 본문을 몇 글자씩 잘라서 인덱싱하는 방법
	- 자른 글자중 불용어를 걸러내고 남은 글자를 인덱스로 등록한다.
	- 보통 2글자 기준인 2-gram을 사용한다.
- 불용어 변경 및 삭제
	- 불용어처리에 혼란이 있을 수 있어 무시하는 기능을 제공한다.
	- 사용자 정의 불용어를 등록할 수 있다.
#### 전문 검색 인덱스의 가용성
- 쿼리 문장이 전문 검색을 위한 문법 (MATCH ... AGAINST ... ) 을 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유
- `LIKE '%애플%'` 을 사용하면 전문 검색 인덱스를 이용해 효율적으로 쿼리가 실행된 것이 아니라 풀 테이블 스캔으로 처리한다.
- `MATCH(doc_body) AGAINST('애플' IN BOOLEAN MODE)` 로 검색 쿼리를 작성해야 전문 검색 인덱스를 사용하게 된다.


## 멀티 밸류 인덱스
- JSON 같은 형태로 1개의 레코드에 여러 개의 키값을 가질 수 있는 형태의 인덱스다.
## 클러스터링 인덱스
- 비슷한 레코드를 묶어서 저장한다.
- InnoDB 스토리지 엔진에서만 지원한다.
### 클러스터링 인덱스
- 프라이머리 키에 대해서만 적용되는 내용이다.
- 테이블의 레코드가 프라이머리키에 정렬되어 저장된다.
- B-Tree 는 리프노드에 세컨더리 인덱스가 있지만 클러스터링 인덱스는 리프노드에 모든 칼럼이 같이 저장돼 있다.
- 클러스터링 인덱스 선택 우선순위
	- 1. 프라이머리키
	- 2. NOT NULL 옵션의 유니크 인덱스중 첫 번째 인덱스
	- 3. 자동으로 유니크한 값을 가지도록 증가되는 칼람을 내부적으로 추가
### 세컨더리 인덱스에 미치는 영향
- MyISAM 은 세컨더리 인덱스가 해당 레코드의 주소를 저장하고 있지만
- InnoDB는 세컨더리 인덱스가 프라이머리 키 값을 저장하도록 구현돼 있다.
### 클러스터링 인덱스의 장점과 단점
- 장점
	- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름(특히, 범위 검색)
	- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
	- 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
	- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 검색해야해서 성능이 느림
	- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되어 성능이 느림
	- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 성능이 느림
### 클러스터링 테이블 사용시 주의사항
- 프라이머리 키가 커지면 인덱스의 크기가 커지고 메모리가 더 필요해진다.
- 프라이머리 키는 AUTO-INCREMENT 보다 업무적인 칼럼으로 생성
	- 프라이머리 키로 검색하는 것이 빠르기 때문이다.
- 프라이머리 키를 반드시 명시
	- 명시하지 않으면 자동으로 일련번호 칼람을 추가해서 정렬한다.
- AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우
	- 복합으로 프라이머리 키가 만들어지는 경우 세컨더리 인덱스가 필요없다면 사용하는 것이 좋다.
	- 세컨더리 인덱스도 필요하다면 AUTO_INCREMENT 칼럼을 추가하고 프라이머리 키로 설정
## 유니크 인덱스
### 유니크 인덱스와 세컨더리 인덱스의 비교
#### 인덱스 읽기
- 유니크 인덱스가 빠르다고 할 수 없다.
- 유니크하지 않은 세컨더리 인덱스는 디스크 읽기를 한번 더하는 것이 아닌 CPU에서 칼럼값 비교만 한번 더한다.
- 단지 유니크하지 않으면 읽어야한 레코드가 많을 뿐이다.
#### 인덱스 쓰기
- 유니크한지 중복 값 체크를 할 때는 읽기 잠금을 사용
- 쓰기를 할 때는 쓰기잠금을 사용
- 데드락이 빈번히 발생한다.
- 인덱스 키의 저장을 위한 체인지 버퍼를 사용하지 못한다.
### 유니크 인덱스 사용 시 주의사항
- 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요가 없다.
- 프라이머리 키와 동일하게 생성할 필요도 없다.
## 외래키
- 자동으로 인덱스가 생성된다.
- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다.
- 외래키와 연관되지 않은 칼람의 변경은 최대한 점금 경합을 발생시키지 않는다.
- 부모테이블이 쓰기락 상태이면 자식테이블이 대기한다
- 외래키를 설정하면 해당 키가 부모테이블에 있는지 확인한다.
	- 이런 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다.
	- 잠금이 확장되면 전체적으로 쿼리의 동시 처리에 영향을 미친다.

---

인덱스를 사용하는 이유
- 조건을 만족하는 튜플을 빠르게 조회하기 위해
- 빠르게 정렬하거나 그룹핑 하기 위해
B-Tree 의 시간 복잡도 
- O(log N)
인덱스를 만들 수 록 각각의 테이블이 존재하는 것이다.
- write할 때마다 모든 인덱스 테이블을 변경해야한다.
- 추가적인 저장공간을 차지한다.
- 불필요한 index를 만들지 말자
Covering index : 조회하는 attribute들 복합 인덱스가 모두 커버할 때 만들 수 있다.

Hash index : 시간 복잡도 O(1), rehashing에 대한 부담, 동등만 비교가능, range 비교 불가능, 복잡 인덱스의 경우 전체 attributes에 대한 조회만 가능

Binary-Tree보다 B-Tree가 선호되는 이유 : block단위로 읽고 쓰는 것이 디스크 I/O를 줄일 수 있기 때문이다.
	자녀 노드 수가 많다.
	깊이를 줄일 수 있다.



## 질문
1. 인덱스의 크기가 정확히 무엇을 의미하는가?
2. 클러스터링 인덱스와 B-Tree 인덱스의 차이가 뭔가요?
3. 클러스터링 인덱스는 따로 걸어줘야하는 건가?
4. 유니크 인덱스를 거는 것과 유니크 제약조건만 거는 것은 전혀 다른가?
5. 유니크하지만 해당 컬럼으로 조회하는 경우가 없다. 이래도 인덱스를 사용하는 것이 좋은 건가?
