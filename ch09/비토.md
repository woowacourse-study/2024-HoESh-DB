# 9.1 개요

## 9.1.1 쿼리 실행 절차

- **쿼리가 실행되는 과정**
    1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
        - **SQL 파싱** 단계
        - **SQL 파서**라는 모듈로 처리
        - SQL 문장의 문법적으로 잘못됐다면 이 단계에서 걸러짐
        - SQL 파스 트리 생성
    2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
        - **최적화 및 실행 계획 수립** 단계
        - 불필요한 조건 제거 및 복잡한 연산의 단순화
        - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
        - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
    3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
        - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
        - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업 수행
    - 첫 번째와 두 번째 단계는 거의 MySQL 엔진에서 처리하며, 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리

## 9.1.2 옵티마이저의 종류

- 데이터베이스 서버에서 두뇌와 같은 역할을 담당
- **규칙 기반 최적화**
    - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    - 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 실행 계획이 수립됨
        - 따라서, 같은 쿼리에 대해서는 거의 항상 같은 실행 방법 생성
        - 하지만 사용자의 데이터 분포도는 매우 다양하므로 거의 사용하지 않음
- **비용 기반 최적화**
    - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
    - 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리 실행

# 9.2 기본 데이터 처리

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- MySQL 옵티마이저에서 풀 테이블 스캔을 선택하는 경우
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
    - `WHERE` 절이나 `ON` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
- InnoDB 스토리지 엔진에선 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작됨

<aside>
💡 **리드 어헤드(Read ahead)**

어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것

</aside>

- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
- 백그라운드 스레드가 읽기를 넘겨받은 시점부터 한 번에 4개 또는 8개씩의 페이지를 읽으면서 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장
- 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리됨
- `innodb_read_ahead_threshold` 시스템 변수를 사용해 리드 어헤드 시작 임계값 설정
- 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용됨

## 9.2.2 병렬 처리

- 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것
- MySQL 8.0에서는 `innodb_parallel_read_threads` 라는 시스템 변수를 이용해 스레드 개수 설정 가능
- 아무런 `WHERE` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능
- 병렬 처리용 스레드 개수를 아무리 늘려도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있음

## 9.2.3 ORDER BY 처리(Using filesort)

- 정렬 처리 방법
    - **인덱스 이용**
        - 장점
            - `INSERT` , `UPDATE` , `DELETE` 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름
        - 단점
            - `INSERT` , `UPDATE` , `DELETE` 작업 시 부가적인 인덱스 추가, 삭제 작업이 필요하므로 느리다.
            - 인덱스 때문에 디스크 공간이 더 많이 필요하다.
            - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
    - **Filesort 이용**
        - 장점
            - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
            - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
        - 단점
            - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.
        - 실행 계획의 `Extra` 칼럼에 `Using filesort` 메시지가 표시되는지 여부로 판단 가능
- **소트 버퍼(Sort buffer)**
    - 정렬을 수행하기 위해 할당받은 별도의 메모리 공간
    - 정렬이 필요한 경우에만 할당
    - `sort_buffer_size` 라는 시스템 변수로 최대 사용 가능한 소트 버퍼의 공간 크기 설정 가능
    - 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 클 경우
        - 메모리의 소트 버퍼에서 정렬을 수행 후, 그 결과를 임시로 디스크에 기록
        - 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장
        - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행(멀티 머지)
        - 위 작업들이 모두 디스크의 쓰기와 읽기를 유발
    - 소트 버퍼는 세션 메모리 영역(여러 클라이언트가 공유해서 사용X)
        - 커넥션이 많을수록, 정렬 작업이 많을수록 메모리 공간이 커짐
- **정렬 알고리즘**
    - 옵티마이저 트레이스 기능으로 어떤 정렬 모드를 사용했는지 확인 가능
        - `<sort_key, rowid>`
            - **투 패스 방식**
            - 정렬 키와 레코드의 로우 아이디(PK 값)만 가져와서 정렬하는 방식
        - `<sort_key, additional_fields>`
            - **싱글 패스 방식**
            - 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
        - `<sort_key, packed_additional_fields>`
            - **싱글 패스 방식**
            - 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리 저장
    - 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합리
    - 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요
    - MySQL 서버에서 싱글 패스 정렬 방식을 사용하지 못하고 투 패스 정렬 방식을 사용하는 경우
        - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
        - `BLOB` 이나 `TEXT` 타입의 칼럼이 `SELECT` 대상에 포함될 때
- 쿼리에 `ORDER BY` 가 사용될 3가지 방식 중 하나로 정렬 처리됨(아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어짐)
    1. 인덱스를 사용한 정렬
        - `Extra` 칼럼에 별도 표기 없음
        - `ORDER BY` 절에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, `ORDER BY` 의 순서대로 생성된 인덱스가 있어야 함
        - `WHERE` 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 `ORDER BY` 는 같은 인덱스를 사용할 수 있어야 함
        - 해시 인덱스나 전문 검색 인덱스, R-Tree도 이 방식 사용X
        - 인덱스를 이용해 정렬이 처리되는 경우 MySQL 엔진에서 별도의 정렬을 위한 추가 작업 수행X
    2. 조인에서 드라이빙 테이블만 정렬
        - `Extra` 칼럼에 `Using filesort` 메시지가 표시됨
        - 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 `ORDER BY` 절을 작성
    3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
        - `Extra` 칼럼에 `Using temporary; Using filesort` 메시지가 표시됨
        - `ORDER BY` 절의 정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 칼럼
- 인덱스를 이용할 수 있다면 별도의 **Filesort**과정 없이 인덱스를 순서대로 읽어서 결과 반환
- 인덱스를 사용할 수 없다면 2, 3번의 방법 중 하나로 처리
- **쿼리가 처리되는 방법**
    - **스트리밍 방식**
        - 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
        - 클라이언트는 일치하는 레코드를 찾는 즉시 전달받아 동시에 데이터의 가공 작업 시작 가능
        - 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간 보장
        - `LIMIT` 조건을 추가하면 전체적으로 가져오는 레코드 건수가 줄어 마지막 레코드를 가져오기까지 시간 단축
        - 인덱스를 사용한 정렬 방식에서 사용
    - **버퍼링 방식**
        - `ORDER BY` , `GROUP BY` 같은 처리는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함
        - MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려짐
        - `LIMIT` 로 결과 건수를 제한하는 것이 성능 향상에 별로 도움X
        - 인덱스를 사용하지 못하는 경우에 사용
- `SHOW STATUS LIKE 'Sort%';` 로 정렬 작업의 내용 확인 가능

## 9.2.4 GROUP BY 처리

- `GROUP BY` 에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 `HAVING` 절을 튜닝하기 위해 인덱스를 생성하거나 다른 방법을 고민할 필요X
- `GROUP BY` 작업 방식
    - **인덱스 스캔을 이용하는 `GROUP BY` (타이트 인덱스 스캔)**
        - 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 `GROUP BY` 칼럼으로 이미 인덱스가 있다면 인덱스를 사용해 그루핑
    - **루스 인덱스 스캔을 이용하는 `GROUP BY`**
        - 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용 가능
        - 인덱스 레인지 스캔은 유니크한 값이 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 유니크한 값의 수가 적을수록 성능이 향상됨
        - 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
            - `MIN()` , `MAX()` 이외의 집합 함수를 사용
            - `GROUP BY` 에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않음
            - `SELECT` 절의 칼럼이 `GROUP BY` 와 일치하지 않음
    - **임시 테이블을 사용하는 `GROUP BY`**
        - `GROUP BY` 의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때 사용

## 9.2.5 DISTINCT 처리

- **`SELECT DISTINCT`**
    - 단순히 `SELECT` 되는 레코드 중에서 유니키한 레코드만 가져오고자 하면 `GROUP BY` 와 동일한 방식으로 처리됨
    - `DISTINCT` 는 `SELECT` 하는 레코드(튜플)를 유니크하게 `SELECT` 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
- **집합 함수와 함께 사용된 `DISTINCT`**
    - 집합 함수 내에서 사용된 `DISTINCT` 는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

## 9.2.6 내부 임시 테이블 활용

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적으로 임시 테이블을 사용한다.
- 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제됨
- 메모리용 임시 테이블을 MEMORY와 TempTable 중에서 선택 가능. 기본값은 TempTable.
- 디스크 저장 방식
    - MMAP 파일로 디스크에 기록
    - InnoDB 테이블로 기록
    - MMAP 파일로 전환하는 것이 InnoDB 테이블로 전환하는 것보다 오버헤드가 적기 때문에 기본값은 MMAP이다.
    - `temptable_use_map` 시스템 변수로 설정 가능
- **임시 테이블이 필요한 쿼리**
    - `ORDER BY` 와 `GROUP BY` 에 명시된 칼럼이 다른 쿼리
    - `ORDER BY` 나 `GROUP BY` 에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
    - `DISTINCT` 와 `ORDER BY` 가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT` 가 인덱스로 처리되지 못하는 쿼리
    - `UNION` 이나 `UNION DISTINCT` 가 사용된 쿼리(`select_type` 칼럼이 `UNION RESULT` 인 경우)
    - 쿼리의 실행 계획에서 `select_type` 이 `DERIVED` 인 쿼리
- **임시 테이블이 디스크에 생성되는 경우**
    - `UNION` 이나 `UNION ALL` 에서 `SELECT` 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    - `GROUP BY` 나 `DISTINCT` 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
    - 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) `tmp_table_size` 또는 `max_heap_table_size` 시스템 변수보다 크거나 (TempTable 스토리지 엔진에서) `temptable_max_ram` 시스템 변수 값보다 큰 경우
- **임시 테이블 관련 상태 변수**
    - `SHOW SESSION STATUS LIKE 'Created_tmp%';` 로 확인 가능