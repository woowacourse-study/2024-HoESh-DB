# 11장 쿼리 작성 및 최적화

DDL: Data Definition Language
DML: Data Manipulation Language

MySQL 서버는 운영체제에 따라 테이블명의 대소문자 구분이 다르니 웬만하면 초기 DB나 테이블을 생성할 때 대문자 또는 소문자로 통일하자.

예약어 확인하는 방법은 백틱(`) 또는 쌍따옴표로 감싸지 않은 채로 테이블명으로 생성해보는 것. 예외가 발생한다면 예약어임 

# 11.3 MySQL 연산자와 내장 함수

## 11.3.1 리터럴 표기법 문자열

### 11.3.1.1 문자열

문자열은 따옴표로 감싸서 표기

### 11.3.1.2 숫자

숫자값을 상수로 표현하려면 따옴표 없이 입력

문자열 형태로 입력하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 숫자 값으로 타입 변환해줌. 

```sql
select * from tab_test where number_column = '1001';
select * from tab_test where string_column = 1001;
```

위 쿼리에서 두 비교 대상의 타입이 다르기 때문에 타입 변환이 발생

MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행

첫번째 쿼리에서는 상수 ‘1001’ 을 문자열에서 숫자로 변환. 상수값 하나만 변경하므로 성능 문제가 발생하지 않음

두번째 쿼리에서는 1001을 문자열로 변환하는 게 아니라 앞서 말했듯이 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 string_column 칼럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행한다. 때문에 string_column에 인덱스가 있더라도 이용하지 못할 뿐더러 string_column에서 숫자로 변환하지 못하는 문자열이 있는 경우 예외가 발생.

### 11.3.1.4 불리언

불리언은 사실 TINYINT

## 11.3.2 MySQL 연산자

### 11.3.2.1 동등(Equal) 비교(=, <=>)

= 은 단순 비교, <=>은 NULL-Safe 비교 연산자

`mysql> select 1 = 1, NULL = NULL, 1 = NULL;` 

| 1 = 1 | NULL = NULL | 1 = NULL |
| --- | --- | --- |
| 1 | NULL | NULL |

`mysql> select 1 <=> 1, NULL <=> NULL, 1 <=> NULL;`

| 1 <=> 1 | NULL <=> NULL  | 1 <=> NULL |
| --- | --- | --- |
| 1 | 1 | 0 |

### 11.3.2.5 나누기(/, DIV)와 나머지(%, MOD) 연산자

- `/` 연산은 몫과 나머지 모두 반환 ex) 29 / 9 ⇒ 3.222
- `DIV` 연산은 몫만 반환 ex) 29 DIV 9 ⇒ 3
- `MOD` , `%` 연산은 나머지 반환 ex) 29 MOD 9 ⇒ 2, 29 % 9 ⇒ 2

### 11.3.2.6 REGEXP 연산자

`mysql> SELECT 'abc' regexp '^[x-z]';`  ⇒ 0

‘abc’라는 문자열이 ‘x’,’y’,’z’ 문자로 시작하는지 검증하는 표현식

REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔 사용 불가. 따라서 REGEXP 연산자는 인덱스를 전혀 사용하지 못한다는 단점이 있지만 LIKE 연산자는 인덱스를 이용해 처리 가능

다만 LIKE 연산자에서도 와일드카드 문자(%, _)가 검색어 앞쪽에 있다면 인덱스 레인지 스캔 사용불가

### 11.3.2.8 BETWEEN 연산자

```sql
select * from dept_emp
where dept_no = 'd003' and emp_no = 10001;

select * from dept_emp
where dept_no between 'd003' and 'd005' and emp_no = 10001;
```

demp_emp 테이블에는 (dept_no, emp_no)로 인덱스가 걸려있다. 

첫번째 쿼리는 인덱스를 잘 타서 호율적으로 데이터를 가져오지만, between 을 사용한 두번째 쿼리는 dept_no가 ‘d003’보다 크거나 같고 ‘d005’보다 작거나 같은 모든 인덱스의 범위를 검색해야만 한다. 때문에 emp_no = 10001 조건은 비교 범위를 졸이는 역할을 하지 못한다. 

```sql
select * from dept_emp
where dept_no in ('d003', 'd004', 'd005') and empt_no = 10001;
```

between이 선형으로 인덱스를 검색해야 하는 것과는 달리 IN은 동등(Equal) 비교를 여러 번 수행하는 것과 같은 효과가 있기 때문에 dept_emp 테이블의 인덱스 (dept_no, emp_no)를 최적으로 사용할 수 있다.

### 11.3.3.2 현재 시각 조회(now, sysdate)

```sql
mysql> select now(), sleep(2), now();

+--------------------+----------+--------------------+
| now()              | sleep(2) | now()              |
+--------------------+----------+--------------------+
|2023-02-28 14:55:23 | 0        |2023-02-28 14:55:23 |
+--------------------+----------+--------------------+

mysql> select sysdate(), sleep(2), sysdate();

+--------------------+----------+--------------------+
| sysdate()          | sleep(2) | sysdate()          |
+--------------------+----------+--------------------+
|2023-02-28 14:55:23 | 0        |2023-02-28 14:55:25 |
+--------------------+----------+--------------------+

```

sysdate() 함수는 이러한 특성 탓에 두 가지 큰 잠재적인 문제가 있음.

- sysdate() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다
- sysdate() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다.

  (작성중)
