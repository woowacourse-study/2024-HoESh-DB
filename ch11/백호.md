## 쿼리 작성과 연관된 시스템 변수
### SQL 모드
- STRICT_ALL_TABLES & STRICT_TRANS_TABLES
	- INSERT 나 UPDATE 로 데이터를 변경하는 경우 자동 타입 변경이 되는데 이때 에러를 발생할지 결정
- ANSI_QUOTES
	- 문자표현 "" or '' 가 MySQL에서는 둘다 됨. 하지만 오라클은 '' 만 되고 "" 는 칼럼명 구분으로 사용됨.
	- 옵션으로 ''만 쓰게 강제할 수 있음.
- ONLY_FULL_GROUP_BY
	- SELECT절에 GROUP_BY에 사용된 컬럼과 집계함수만 올 수 있다.
	- MySQL 8.0부터 기본으로 활성화됨.
- PIPES_AS_CONCAT
	- || 를 문자 연결 연산자로 사용.
- PAD_CHAR_TO_FULL_LENGTH
	- CHAR 타입도 문자열 뒤의 공백 문자가 제거되어 반환됨.
- NO_BACKSLASH_ESCAPES
	- 역슬래시가 이스케이프 문자로 사용된다.
	- 활성화하면 이스케이프 용도로 사용하지 못한다.
- IGNORE_SPACE
	- 프로시저나 함수명과 괄호 사이의 공백을 무시한다.
- REAL_AS_FLOAT
	- REAL타입이 원래 DOUBLE 타입이지만 FLOAT로 바뀐다.
- NO_ZERO_IN_DATE && NO_ZERO_DATE
	- 0000같은 잘못된 날짜를 저장하지 못한다.
- ANSI
	- SQL표준에 맞게 동작하게 만든다.
- TRADITIONAL
	- 여러 모드를 조합해둠.
### 영문 대소문자 구문
- 윈도우는 대소문자 구분하지 않음.
- 유닉스 계열은 대소문자 구분함.
### MySQL 예약어
예약어는 역따옴표나 쌍따옴표로 감싸야한다.

## MySQL 연산자와 내장 함수
- 문자열 : '' 와 "" 를 혼용한다. 문자열 값에 홑따옴표가 포함돼 있는 경우 두번 연속 입력하면 된다.
- 숫자 : 문자열과 숫자값을 비교하면 자동으로 문자열 값을 숫자 값으로 변환한 후 비교한다.
	- 칼럼이 문자인데 숫자로 비교하면 칼럼의 값을 전부 숫자로 바꿔 쿼리를 실패할 수 있다.
- 날짜 : MySQL은 날짜와 문자를 비교할 때 문자를 변환해주지 않아도 된다.
- 불리언 : TINYINT 으로 0, 1로 저장한다.
- 동등 비교 : <=> NULL에 대한 비교도 수행.
- NOT : 부정
- AND, OR : &&, || 도 사용할 수 있지만 가독성을 위해 자제하자.
	- 순서 상관 없이 괄호를 묶지 않으면 AND 연산이 우선순위가 높다.
- DIV, /, %, MOD : 나머지, 몫
- REGEXP : 정규표현식 비교
- LIKE : 문자 비교 인덱스 사용가능
	- % : 0또는 1개 문자 일치
	- _ : 정확히 1개의 문자 일치
	- 와일드카드가 앞쪽에 있으면 인덱스 레인지 스캔을 사용할 수 없다.
- BETWEEN : 범위를 지정하여 찾는다.
	- 조건이 더 붙으면 인덱스 레인지 스캔에 필터링을 추가해야한다.
	- IN을 사용하면 동등조건 비교와 같아져 최적화를 할 수 있다.
	- IN 내부에 서브 쿼리를 사용하면 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.
- IN : 여러번의 동등 비교로 실행하여 일반적으로 빠르게 처리된다.
	- NOT IN : 인덱스를 사용할 수 없다.
- IFNULL() : NULL 이면 대체
- ISNULL() : NULL 인지 불리언 반환
- NOW() : 현재 시간
- SYSDATE() : 호출되는 시점에 따라 시간이 달라짐
	- 인덱스를 효율적으로 사용하지 못한다.
	- 레플리카 서버에서 안정적으로 복제되지 못한다.
	- 쓸 이유가 없다.
	- 레코드 비교마다 함수를 실행해서 비교한다.
- DATE_FORMAT, STR_TO_DATE : 문자열 날짜 변환시 포멧을 지정할 때 사용.
- DATE_ADD, DATE_SUB : DATE_ADD(NOW(), INTERVAL 1 DAY) 형식으로 날짜 연산
- UNIX_TIMESTAMP, FROM_UNIXTIME : 1970-01-01로 부터 경과된 초의 수를 반환, 변환
- RPAD, LPAD / RTRIM, LTRIM, TRIM : RPAD('abc', 10, '0' ) 로 패딩할 문자 및 길이 입력
- CONCAT : 문자 결합
- GROUP_CONCAT : GROUP BY 가 없이 사용되면 하나의 결과값으로 연결한다.
- CASE WHEN THEN : switch 문, 조건을 제한해서 서브쿼리 실행 횟수를 줄일 수 있다.
- CAST, CONVERT : CAST('1234' AS SIGNED INTEGER) 타입 변환. CONVERT('ABC' USING 'utf8mb4') 문자 집합 변환
- HEX, UNHEX: 이진값 변환
- MD5, SHA : 비대칭형 암호화 알고리즘. URL같은 경우 16바이트로 줄일 수 있어 인덱스  생성에 효율적이다.
	- 더 줄이려면 UNHEX() 함수로 이진값으로 만들면 된다.
- SLEEP : 처리 대기
- BENCHMARK : 스칼라 값을 반환하는 함수나 쿼리의 반복 실행 시간 측정.
	- 한번의 네트워크, 쿼리 파싱 및 최적화 비용이 소모되어 쿼리를 여러번 실행한 것과는 차이가 있다.
	- 동일한 기능을 상대적으로 비교 분석하는 용도로 사용하는 것이 권장된다.
-  IP 주소 변환
	- INET_ATON : IPv4  주소를 문자열이 아닌 부호없는 정수 타입에 저장할 수 있다.
- JSON_PRETTY : json 형식을 읽기 쉬운 포맷으로 변환
- JSON_STORAGE_SIZE : json 타입을 저장할 때 binary json 포맷을 사용하므로 크기를 예측하기 어렵다. json의 크기를 반환하는 함수다.
- JSON_EXTRACT : json의 특정 필드를 가져오는 함수다.
	- 기본적으로 "" 가 붙어서 가져온다.
	- JSON_UNQUOTE 를 사용해서 값만 가져올 수 있다.
	- `doc -> "$.first_name"`, `doc ->> "$.first_name"` : 이 문법으로 바꿀 수 있다.
- JSON_CONTAINS : json 경로에 필드를 가지고 있는지 확인하는 함수
- JSON_OBJECT : 칼럼으로 직접 json 객체를 생성한다.
- JSON_OBJECTAGG & JSON_ARRAYAGG : group by 와 함께 사용되는 집계함수
- JSON_TABLE : json 데이터를 모아 테이블로 반환

## SELECT
### SELECT 절의 처리 순서
- 인덱스를 사용하지 못하는 경우
	- 드라이빙 테이블 FROM -> WHERE -> 드리븐 테이블 JOIN -> GROUP BY -> DISTINCT -> HAVING -> ORDER BY -> LIMIT
- 인덱스를 사용하는 경우
	- 드라이빙 테이블 FROM -> WHERE -> ORDER BY -> 드리븐 테이블 JOIN -> LIMIT
- 서브쿼리를 사용하는 경우
	- 인 라인 뷰를 사용하여 서브쿼리를 먼저 실행한다.
	- 임시 테이블이 사용되기 때문에 주의해야한다.
### WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
#### 인덱스를 사용하기 위한 기본 규칙
- 인덱스 칼럼의 값을 변환하지 않는다.
- WHERE 절의 비교 조건에서 양쪽 타입이 일치해야한다.
#### WHERE 절의 인덱스 사용
- WHERE 절의 순서가 인덱스 순서와 달라도 옵티마이저가 최적화를 수행한다.
- OR 절은 둘 중 하나라도 인덱스 칼럼이 아니면 풀 테이블 스캔을 한다.
	- 둘다 인덱스 칼럼이라면 index_merge 를 수행한다.
		- 풀 테이블보다는 빠르지만 인덱스 레인지 스캔보다 느리다.
#### GROUP BY 절의 인덱스 사용
- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야한다.
- 인덱스의 앞쪽 칼럼이 GROUP BY에 명시되지 않으면 인덱스를 사용할 수 없다.
- 인덱스의 뒷쪽 칼럼은 명시되지 않아도 인덱스를 사용할 수 있다.
- GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 인덱스를 전혀 이용하지 못한다. 
- WHERE 절과 함께 사용되면 인덱스의 앞쪽 컬럼이 WHERE절에 명시되고 뒷쪽 컬럼이 GROUP BY 절에 명시되면 인덱스를 사용할 수 있다. `WHERE COL_1= '상수' GROUP BY COL_2, COL_3`
#### ORDER BY 절의 인덱스 사용
- 정렬 옵션이 인덱스와 같거나 정반대인 경우만 사용할 수 있다.
- 인덱스의 앞쪽 컬럼이 먼저 와야한다.
#### WHERE 조건과 ORDER BY(GROUP BY) 절의 인덱스 사용
- WHERE, ORDER BY 둘다 같은 인덱스 이용
	-  가장 빠르다.
- WHERE 절만 인덱스 이용.
	- Filesort 로 정렬을 따로 수행해야한다.
	- WHERE 절의 조건에 일치하는 레코드 건수가 많지 않을 때 효율적
- ORDER BY 절만 인덱스 이용
	- 인덱스 순서대로 읽으면서 WHERE 조건을 비교한다.
	- 많은 레코드를 조회해서 정렬해야할 때 사용.
- `WHERE COL_1= '상수' ORDER BY COL_2, COL_3` : 이런 경우는 인덱스를 탈 수 있다.
- `WHERE COL_1 > '상수' ORDER BY COL_2, COL_3` : 이런 경우 인덱스 첫번째 컬림이 범위 인데 정렬 조건이 2번째 컬럼부터여서 인덱스를 탈수없다.

#### GROUP BY 절과 ORDER BY 절의 인덱스 사용
- GROUP BY 칼럼과 ORDER BY 칼럼의 순서 내용 모두 똑같아야 인덱스를 탈 수 있다.
- 둘 중 하나라도 인덱스를 탈 수 없는 경우 모두 인덱스를 이용하지 못한다.

#### WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
1. WHERE 절이 인덱스를 사용할 수 있는가?
	- YES : GROUP BY 절이 인덱스를 사용할 수 있는가?
		- YES : ORDER BY 절이 인덱스를 사용할 수 있는가?
			- YES : 모두 인덱스 사용
			- NO : WHERE 절만 인덱스 사용
		- NO : WHERE 절만 인덱스 사용
	-  NO : GROUP BY 절이 인덱스를 사용할 수 있는가?
		- YES : ORDER BY 절이 인덱스를 사용할 수 있는가?
			- YES : GROUP BY, ORDER BY 인덱스 사용
			- NO : 인덱스 전혀 사용 못함
		- NO : 인덱스 전혀 사용 못함

### WHERE  절의 비교 조건 사용 시 주의사항
- NULL 비교
	- `ISNULL()`을  사용하면 인덱스 레인지 스캔을 할 수 있지만 `ISNULL()=1` 을 사용하면 풀 스캔 처리된다.
- 문자열이나 숫자 비교
	- 칾렁에 맞는 타입을 사용해라
	- 문자와 숫자를 비교하면 문자를 숫자로 변환해서 비교를 수행한다.
		- 문자 칼럼을 전부 숫자로 변환해야해서 인덱스를 사용하지 못한다.
- 날짜 비교
	- DATE, DATETIME과 문자를 비교할 때 문자열을 DATETIME 타입 값으로 변환해서 비교를 수행한다.
	- 날짜를 강제로 문자열로 변경하면 인덱스를 효율적으로 사용하지 못한다.
	- 날짜 타입 칼럼의 값을 더하거나 뺴는 함수로 변형한 후 비교하면 인덱스를 사용할 수 없다.
		- 상수를 변형하는 형태로 쿼리를 짜라
- DATE, DATETIME 비교
	- 변환하지 않고 비교하면 DATE가 시간에 0이 추가되어 비교된다.
- DATETIME, TIMESTAMP 비교
	- UNIX_TIMESTAMP는 단순 숫자 값이므로 비교할 수 없다.
- Short-circuit Evaluation
	- AND나 OR 조건에서 앞에 실행부분을 먼저 체크하고 뒤를 체크하지 않아 성능을 개선한다.
	- 인덱스를 사용할 수 있으면 인덱스를 먼저 탄다.
	- 인덱스를 사용할 수 없으면 앞의 조건이 먼저 실행된다.
### DISTINCT
1:1, 1:N 조인인지 판단해서 사용하자.

### LIMIT n
- 항상 쿼리의 마지막에 실행
- 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다.
- 숫자가 커지면 상당히 오래걸린다.
- WHERE 조건으로 짜르고 LIMIT를 거는 것이 좋다.
### COUNT
- InnoDB는 테이블 레코드 수를 관리하지 않고 있어 직접 데이터나 인덱스를 읽어야한다.
- ORDER BY나 LEFT JOIN랑 같이 쓰지마라. - 옵티마이저가 무시하긴 함
- 인덱스를 사용하지못하면 부하를 일으킨다.
- `COUNT(*)` 는 NULL 도 카운트한다.
### JOIN
- 인덱스 스캔 작업보다 인덱스 탐색 작업의 부하가 큰 편이다.
	- 일반적으로 가져오는 레코드의 건수가 소량이다.
- 드라이빙 테이블 탐색 1번, 드리븐 테이블 탐색 ,스캔을 드라이빙 테이블 레코드 건수만큼 반복
- 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다.
- 옵티마이저는 드리븐 테이블을 최적으로 읽을 수 있게 실행계획을 수립한다.
- JOIN 시 2 테이블 컬럼 모두 인덱스가 있는 경우 : 옵티마이저가 통계로 판단한다.
- 한 테이블에만 인덱스가 있는 경우 : 인덱스가 존재하는 테이블을 드리븐 테이블로 선택한다.
	- 인덱스가 없는 테이블을 건수만큼 풀 테이블 스캔을 하는 것이 비효율적이기 때문이다.
- 두 테이블 모두 인덱스가 없는 경우 : 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 효율적이다.
	- 이 경우 해시 조인으로 처리된다.
- 타입 불일치로 인덱스를 못타는 경우
	- CHAR, INT 비교
	- CHAR에서 문자집합이나 콜레이션이 다른 경우
	- INT 인데 부호의 존재여부가 다른 경우
#### OUTER JOIN의 성능과 주의사항
- 테이블의 데이터가 일관되지 않은 경우에만 OUTER JOIN이 필요하다.
- OUTER로 JOIN 되는 테이블은 절대 드라이빙 테이블이 될 수 없어 풀 스캔이 필요하다.
- OUTER JOIN 의 조건을 WHERE 조건에 명시하는 것은 잘못된 방법이다.
	- MySQL 서버가  LEFT JOIN을 INNER JOIN으로 자동 변환한다.
	- WHERE 절을 사용하는 경우는 IS NULL 조건으로 안티 조인하는 경우만 유일하다.

#### JOIN과 외래키(FOREIGN KEY)
- 외래키는 조인과 아무런 연관이 없다.
- 데이터의 무결성을 보장하기 위해 외래키가 존재한다.

#### Delayed Join
- JOIN 과 GROUP BY를 해야하는 상황
	- JOIN을 하면 레코드의 건수가 늘어나기 때문에 JOIN전에 GROUP BY나 ORDER BY를 서브쿼리로 처리한다.
- LEFT JOIN 인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야한다.
- 드라이빙 테이블을 서브쿼리로 만들고 LIMIT를 추가해도 결과가 변하지 않는 다는 조건이 필요하다.

#### Lateral Join
- 그룹별로 몇 건씩만 가져오는 쿼리
- 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성된다.

#### 실행 계획으로 인한 정렬 흐트러짐
- 네스티드 루프 조인을 하면 정렬이 되어있지만 해시조인을 사용하면 정렬되지 않는다.

### GROUP BY
#### WITH ROLLUP
- 그룹별 소계 표시
- 전체 소계도 표시
- Grouping : 전체 소계에 이름 지정 가능
#### 레코드를 칼럼으로 변환해서 조회
- 그룹핑을 해서 피벗테이블로 활용한다.

### ORDER BY
- Using filesort : 명시적으로 정렬 수행.
- SHOW STATUS LIKE 'Sort_%';
	- Sort_merge_passes : 0 보다 크면 디스크까지 이용했다는 것을 의미한다.
- 인덱스 정렬 순서를 ORDER BY와 같게 하는 것이 좋다.

### 서브쿼리
#### SELECT 절에 사용된 서브쿼리
- 서브쿼리가 적절한 인덱스를 사용할 수 있다면 크게 주의할 사항이 없다.
- 스칼라 서브쿼리만 사용할 수 있다.
- 반환 값이 없으면 NULL이다.
- 조인으로 가능한 쿼리이면 서브쿼리보다 조인을 활용하는 것이 성능적으로 좋다.
- 같은 서브쿼리를 여러번 실행해야하면 레터럴 조인을 이용할 수 있다.
#### FROM 절에 사용된 서브쿼리
- 예전에는 임시테이블을 만들었지만 지금은 옵티마이저가 최적화를 한다.
- 외부 쿼리와 병합되지 못하는 경우
	- 집계함수 사용
	- DISTINCT
	- GROUP BY
	- LIMIT
	- UNION
	- SELECT 절에 서브쿼리가 사용된 경우
#### WHERE 절에 사용된 서브쿼리
##### 동등 또는 크다 작다 비교
- 8.0 버전부터 서브쿼리를 먼저 실행하여 상수로 변환한다.
##### IN 비교
- 세미 조인이라고 한다.
- 최적화 방안
	- 테이블 풀-아웃
	- 퍼스트 매치
	- 루스 스캔
	- 구체화
	- 중복제거
##### NOT IN 비교
- 최적화 방안
	- NOT EXISTS
	- 구체화
### 잠금을 사용하는 SELECT
- InnoDB는 SELECT 할 때 잠금을 걸지 않는다.
- FOR SHARE : 읽기 잠금
	- 다른 세션에서 쓰기 불가능
	- 다른 세션에서 읽는 것은 가능
- FOR UPDATE : 쓰기 잠금
	- 다른 세션에서 쓰기 불가능
	- 다른 세션에서 FOR SHARE SELECT로 읽는 것이 불가능
	- 다른 세션에서 SELECT로 읽는 것은 가능
#### 잠금 테이블 선택
- JOIN 사용한 쿼리를 FOR UPDATE로 읽으면 테이블에서 읽은 레코드 모두 잠금이 걸린다. (잠금 전파)
- FOR UPDATE OF e : 로 특정 테이블만 잠금을 걸 수 있다.

#### NOWAIT & SKIP LOCKED
- 시간 초과로 잠금 획득에 실패하면 에러메시지를 받는다.
- NOWAIT 옵션으로 잠금 대기를 기다리지 않고 에러를 반환하게 할 수 있다.
- SKIP LOCKED 옵션으로 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져온다.
##### 응용
- 쿠폰 발급
	- 하나의 쿠폰에 쓰기 락을 걸고 읽어오면 나머지 세션이 잠금을 기다리다 타임아웃된다.
	- UPDATE SKIP LOCKED를 사용하면 이미 잠긴 쿠폰을 제외하고 읽어올 수 있다.
	- 레디스를 사용하지 않고 큐를 구현할 수 있다.
 ## INSERT
### INSERT IGNORE
- 레코드의 프라이머리 키나 유니크 인덱스 칼럼이 중복되는 경우 무시하고 다음 레코드 처리.
- 칼럼 조건이 맞지 않는 경우 기본값을 넣는다.
### INSERT ... ON DUPLICATE KEY UPDATE
- 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE문장을 수행한다.
- INSERT ... ON DUPLICATE KEY UPDATE stat_value=stat_value+1; : 이미 존재하면 +1 로 업데이트

### LOAD DATA
- 스토리지 엔진이 직접 데이터를 적재한다.
- 단일 스레드로 실행
- 단일 트랜잭션으로 실행
- INSERT ... SELECT .. 문장으로 프라이머리 키값을 기준으로 데이터를 잘라서 여러개의 스레드로 실행하는 것이 좋다.

### 성능을 위한 테이블 구조
#### 대량 INSERT 성능
- 하나의 INSERT 문으로 여러 레코드를 INSERT한다면 프라이머리 키 값 기준으로 미리 정렬해서 INSERT 문장을 구성하는 것이 성능에 도움이 될 수 있다.
- 세컨더리 인덱스도 정렬 순서가 보장되면 빠른 성능을 얻을 수 있다.
#### 프라이머리 키 선정
- 프라이머리 키를 이용하면 저장될 위치를 인덱스로 빠르게 파악한다.
#### Auto-increment 칼럼
- InnoDB 스토리지 엔진을 사용하면 자동으로 프라이머리 키로 클러스터링 된다.
- Auto-increment 칼럼을 이용하면 클러스터링되지 않는 테이블의 효과를 얻는다.
- 가장 빠른 INSERT를 보장하는 방법이다.

## UPDATE, DELETE
### UPDATE ... ORDER BY ... LIMIT n
- 한번에 너무 많은 레코드를 변경할 경우 과부하를 유발하거나 다른 커넥션의 처리를 방해할 수 있다.
- 나눠서 업데이트한다.
- 문장(STATEMENT) 기반의 복제에서는 주의가 필요하다.
### JOIN UPDATE
- 조인된 테이블의 특정 테이블의 칼럼값을 다른 테이블의 칼럼에 업데이트해야 할 때 주로 사용한다.
- 참조 테이블은 읽기 잠금, 변경 테이블을 쓰기 잠금이 걸린다.
- 데드락에 주의해야햔다.
### 여러 레코드의 UPDATE
- 모든 레코드를 동일한 값으로 업데이트 할 수 있다.
- 레코드 생성 문법을 이용해 레코드별로 서로 다른 값을 업데이트할 수 있다.
### JOIN DELETE
- join 조건에 맞는 레코드를 삭제할 수 있다.
- 여러 테이블에서 동시에 레코드를 삭제할 수 도 있다.\

## 스키마 조작
### 온라인 DDL
- INSTANT
	- 데이터는 변경하지 않고 메타데이터만 변경. 
	- 스카마 변경 도중 테이블 읽고 쓰기는 대기
- INPLACE
	- 테이블의 모든 레코드를 리빌드한다.
	- 스키마 변경 중에 테이블의 읽기 쓰기가 가능
- COPY
	- 임시테이블을 생성하고 레코드를 복사한다.
	- 스키마 변경 도중 읽기만 가능하다.
#### 잠금
- INSTANT
	- 메타데이터 잠금
- INPACE, COPY
	- SHARED : 읽기 잠금
	- EXCLUSIVE : 쓰기 잠금

## 쿼리 성능 테스트
### 쿼리 성능에 영향을 미치는 요소
- 운영체제의 캐시
	- InnoDB는 파일 시스템의 캐시나 버퍼를 거치지 않는 Direct I/O를 사용하여 성능에 큰 차이가 없다.
- MySQL 서버의 버퍼풀 
	- 초기화 하려면 재시작해야한다.
- 독립된 MySQL 서버
