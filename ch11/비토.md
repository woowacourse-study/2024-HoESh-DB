# 11.1 쿼리 작성과 연관된 시스템 변수

## 11.1.1 SQL 모드

- `sql_mode` 라는 시스템 설정을 통해 여러 개의 값을 설정 가능

## 11.1.2 영문 대소문자 구분

- 윈도우 MySQL은 대소문자 구분 X
- 유닉스 계열에선 대소문자 구분

## 11.1.3 MySQL 예약어

- 예약어와 같은 키워드를 사용하기 위해선 역따옴표(`)나 쌍따옴표로 감싸줘야 함

# 11.2 매뉴얼의 SQL 문법 표기를 읽는 방법

- 대괄호(”[]”)는 해당 키워드나 표현식 자체가 해당 사항임을 의미
- 파이프(”|”)는 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택해서 사용할 수 있음을 의미
- 중괄호(”{}”)는 괄호 내의 아이템 중에서 반드시 하나를 사용해야 하는 경우를 의미
- “…” 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미

# 11.3 MySQL 연산자와 내장 함수

## 11.3.1 리터럴 표기법 문자열

- 문자열은 항상 홀따옴표(’)를 사용해서 표시
- 숫자 값을 상수로 사용할 때는 따옴표 없이 숫자 값을 입력

## 11.3.2 MySQL 연산자

> 나중에 읽어봅시다!!!
> 

## 11.3.3 MySQL 내장 함수

> 나중에 읽어봅시다!!!
> 

# 11.4 SELECT

## 11.4.1 SELECT 절의 처리 순서

- WHERE 적용 및 조인 실행 → GROUP BY → DISTINCT → HAVING 조건 적용 → ORDER BY → LIMIT
- 예외적으로 GROUP BY 절이 없이 ORDER BY만 사용된 커리에선 ORDER BY 절이 조인보다 먼저 실행될 수 있다.
    - WHERE → ORDER BY → 조인 → LIMIT
- 이 외 실행 순서를 벗어나는 쿼리가 필요하다면 인라인 뷰를 사용해야 한다.

## 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

- WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 함
- WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.
- WHERE 절에서는 조건절의 순서가 중요하지 않다.
- GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 인덱스를 사용 가능
- 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 사용할 수 있지만 앞쪽에 있는 칼럼이 명시되지 않으면 사용할 수 없음
- ORDER BY 절은 GROUP BY 절의 인덱스 사용 조건 + 정렬되는 각 칼럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다
- WHERE 절과 ORDER BY 또는 GROUP BY 절이 한 쿼리에 있을 시 각각 다른 인덱스를 사용할 수는 없다.
    - 하나에만 적용되거나 같은 인덱스를 사용하도록 쿼리 수정이 필요

## 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항

- SQL 표준에서 NULL의 정의는 비교할 수 없는 값이다. 따라서 두 값이 모두 NULL을 가져도 두 값이 동등한지 비교하는 것은 불가능하다.
- 쿼리에서 NULL인지 비교하려면 `IS NULL` 또는 `<=>` 연산자를 사용해야 한다.
- 문자열이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용할 것을 권장
- 날짜 비교 시에는 칼럼이 아니라 상숫값을 변형하는 형태로 쿼리를 작성

## 11.4.4 DISTINCT

- 9.2.5 절이 더 자세함

## 11.4.5 LIMIT n

- LIMIT 절의 인자로 최대 2개까지 올 수 있음
    - 인자가 1개인 경우 상위 n개의 레코드를 가져옴
    - 인자가 2개인 경우 첫 번째 인자에 지정된 위치부터 두 번째 인자에 명시된 개수만큼의 레코드를 가져옴

## 11.4.6 COUNT()

- COUNT(*) 쿼리에서 ORDER BY 절은 어떤 경우에도 필요치 않다.
- LEFT JOIN 또한 레코드 건수의 변화가 없거나 아우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다.

## 11.4.7 JOIN

- **JOIN 순서와 인덱스**
    - 두 칼럼 모두 인덱스가 있거나 모두 없는 경우 옵티마이저가 적절히 드라이빙 테이블을 선택한다.
    - 둘 중 하나의 칼럼에만 인덱스가 있는 경우 해당 칼럼의 테이블을 드리븐 테이블로 선택한다.
- **JOIN 칼럼의 데이터 타입**
    - 조인에 수행되는 칼럼은 데이터 타입이 일치하는 것이 좋다
- **OUTER JOIN의 성능과 주의사항**
    - 테이블의 데이터가 일관되지 않은 경우에만 아우터 조인이 필요
    - 아우터로 조인되는 테이블에 대한 조건은 WHERE 절에 명시하는 것이 아닌 ON 절에 명시해야 한다.
- **JOIN과 외래키**
    - 조인을 사용하기 위해 외래키가 필요한 것은 아니다
- **지연된 조인**
    - 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미
- **래터럴 조인이라는 것이 있다고 하네요ㅎㅎ**

## 11.4.8 GROUP BY

- **WITH ROLLUP**
    - 엑셀의 피벗 테이블 느낌
- SUM()이나 COUNT()와 같은 집합 함수와 CASE WHEN … END 구문을 이용해 하나의 칼럼을 2개 이상의 칼럼으로 변환하는 것이 가능

## 11.4.9 ORDER BY

## 11.4.10 서브쿼리

- SELECT 절에 사용된 서브쿼리는 적절히 인덱스를 사용할 수만 있다면 크게 주의할 사항은 없다.
- SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용할 수 있다.
- 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르다.
- FROM 절의 서브쿼리는 외부 쿼리로 병합하는 최적화를 수행
    - 아래 기능이 서브쿼리에 사용되면 FROM 절의 서브쿼리는 외부 쿼리로 병합되지 못함
        - 집합 함수 사용(SUM(), MIN(), MAX(), COUNT())
        - DISTINCT
        - GROUP BY 또는 HAVING
        - LIMIT
        - UNION(UNION DISTINCT) 또는 UNION ALL
        - SELECT 절에 서브쿼리가 사용된 경우
        - 사용자 변수 사용(사용자 변수에 값이 할당된 경우)
- WHERE 절에 사용된 서브쿼리는 서브쿼리를 먼저 실행한 후 상수로 변환한다. 그리고 상숫값으로 서브쿼리를 대체해서 나머지 쿼리 부분을 처리한다.
- WHERE 절에 사용된 IN 형태의 조건을 세미 조인이라고 본다.
- 최적화 전략
    - 테이블 풀 아웃
    - 퍼스트 매치
    - 루스 스캔
    - 구체화
    - 중복 제거
- WHERE 절에 사용된 NOT IN 형태의 조건을 안티 세미 조인이라고 한다.
- 최적화 전략
    - NOT EXISTS
    - 구체화

## 11.4.13 잠금을 사용하는 SELECT

- 레코드를 SELECT할 때 레코드에 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기라고 한다.
- SELECT 쿼리를 이용해 읽은 레코드의 칼럼 값을 애플리케이션에서 가공해서 다시 업데이트하고자 할 때는 SELECT가 실행된 후 다른 트랜잭션이 그 칼럼의 값을 변경하지 못하게 해야 한다.
    - FOR SHARE
        - SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 건다.
        - 다른 세션에서 해당 레코드 변경 X
        - 읽는 것은 가능
    - FOR UPDATE
        - SELECT 쿼리로 읽은 레코드에 대해서 쓰기 잠금을 건다.
        - 다른 트랜잭션에서 변경 및 읽기 X
    - 위 옵션은 모두 자동 커밋이 비활성화 된 상태 또는 BEGIN 명령어나 START TRANSATION 명령으로 트랜잭션이 시작된 상태에서만 잠금이 유지
    - FOR UPDATE(SHARE) 뒤에 `OF 테이블` 을 통해 해당 테이블에만 잠금 걸기 가능
    - NOWAIT & SKIP LOCKED
        - 일정 시간이 지나면 잠금 획득 실패 에러 메시지를 받을 수도 있다.
        - NOWAIT
            - 해당 레코드가 다른 트랜잭션에 의해 잠겨진 상태라면 에러를 반환하면서 쿼리 종료
        - SKIP LOCKED
            - SELECT 하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않고 잠긴 레코드는 무시하고 잠금이 걸리지 않은 레코드만 가져옴
        - UPDATE나 DELETE 쿼리에서는 사용 X
