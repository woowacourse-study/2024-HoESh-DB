# 11.5 INSERT

- 많은 INSERT 문장이 실행되는 경우 INSERT 문장 자체보다는 테이블의 구조가 성능에 더 큰 영향을 미친다.

## 11.5.1 고급 옵션

- **`INSERT IGNORE`**
    - 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해준다.
    - 주로 여러 레코드를 하나의 `INSERT` 문장으로 처리하는 경우 유용
    - 프라이머리 키와 유니크 인덱스를 동시에 가지고 있는 경우 하나라도 중복이 발생하는 레코드에 대해서는 `INSERT` 를 무시한다.
    - 데이터 타입이 일치하지 않아서 `INSERT` 를 할 수 없는 경우 칼럼의 기본 값으로 `INSERT` 를 한다.
- **`INSERT ... ON DUPLICATE KEY UPDATE`**
    - 프라이머리 키나 유니크 키에 중복이 발생하면 `UPDATE` 문장의 역할을 수행

## 11.5.2 LOAD DATA 명령 주의 사항

- 내부적으로 MySQL 엔진과 스토리지 엔진의 호출 횟수를 최소화하고 스토리지 엔진이 직접 데이터를 적재하기 때문에 일반적인 `INSERT` 명령과 비교했을 때 매우 빠르다.
- **단점**
    - 단일 스레드로 실행
    - 단일 트랜잭션으로 실행
    - 따라서, 적재할 데이터 파일이 매우 크다면 시간이 길어질 수 있다.
    - 단일 트랜잭션이므로 `LOAD DATA` 문장이 시작한 시점부터 언두로그가 삭제되지 못하고 유지돼야 하므로 더 많은 오버헤드를 만들 수 있다.
- `LOAD DATA` 문장으로 적재할 데이터 파일을 여러 개의 파일로 준비해서 동시에 여러 트랜잭션으로 나뉘어 실행되게 하는 것이 좋다.

## 11.5.3 성능을 위한 테이블 구조

- 하나의 문장으로 대량의 레코드를 `INSERT` 한다면 `INSERT` 될 레코드들을 프라이머리 키 값 기준으로 미리 정렬해서 `INSERT` 문장을 구성하는 것이 성능에 도움이 될 수 있다.
- `SELECT` 보다 `INSERT` 에 최적화된 테이블을 생성하려면 Auto-Increment 칼럼을 이용하면 좋다.

# 11.6 UPDATE와 DELETE

## 11.6.1 UPDATE … ORDER BT … LIMIT n

- 한번에 너무 많은 레코드를 변경 및 삭제하기 보다 `LIMIT` 을 이용해 조금씩 잘라서 변경하거나 삭제하는 방식으로 구현

## 11.6.2 JOIN UPDATE

- 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고, 칼럼이 변경되는 테이블은 쓰기 잠금이 걸린다.

## 11.6.3 여러 레코드 UPDATE

- 레코드 생성 문법을 이용해 레코드별로 서로 다른 값을 업데이트 할 수 있다.

## 11.6.4 JOIN DELETE

- `DELETE` 와 `FROM` 사이에 삭제할 테이블을 명시해서 사용한다.

# 11.7 스키마 조작(DDL)

## 11.7.1 온라인 DDL

- 스키마를 변경하는 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 해준다.
- **`ALGORITHM` 옵션**
    - **INSTANT**
        - 테이블의 데이터 변경 X, 메타 데이터만 변경
        - 작업시간이 매우 짧음
        - 스키마 변경 도중 테이블의 읽고 쓰기는 대기하게 되지만 작업 시간이 짧아 크게 영향 X
    - **INPLACE**
        - 임시 테이블로 데이터를 복사하지 않고 스키마 변경 실행
        - 내부적으로는 테이블의 리빌드를 실행할 수 있음
        - 테이블 크기에 따라 많은 시간 소요 될 수 있음
        - 스키마 변경 도중에도 읽고 쓰기 가능
        - 최초 시작 시점과 마지막 종료 시점에는 읽고 쓰기가 불가능하지만 매우 짧아 영향 X
    - **COPY**
        - 변경된 스키마를 적용한 임시 테이블 생성하고, 테이블의 레코드를 모두 임시 테이블로 복사한 후 임시 테이블을 RENAME해서 스키마 변경을 완료함
        - 테이블 읽기만 가능하고 DML은 불가능
- **`LOCK` 옵션**
    - **NONE**
        - 아무런 잠금을 걸지 않음
    - **SHARED**
        - 읽기 잠금을 걸고 스키마 변경을 실행
    - **EXCLUSIVE**
        - 쓰기 잠금을 걸고 스키마 변경을 실행
- 스키마 변경 작업 종류별로 어떤 알고리즘이 가능한 지가 다름

## 11.7.2 데이터베이스 변경

- 명령어 잘 기억해주자!

## 11.7.3 테이블 스페이스 변경

## 11.7.4 테이블 변경

- `SHOW CREATE TABLE` , `DESC` 명령으로 테이블의 구조를 확인할 수 있다.
- `ALTER TABLE` 명령으로 테이블 구조 변경 가능
- `RENAME TABLE` 명령으로 테이블 명 변경 가능
- `SHOW TABLE STATUS ...` 명령으로 테이블의 상태를 조회 가능
- **테이블 구조 복사**
    - `SHOW CREATE TABLE` 명령으로 테이블의 생성 DDL을 조회한 후 조금 변경해서 만들 수 있음
        - 내용을 조금 변경해야 할 수 있음
    - `CREATE TABLE ... AS SELECT ... LIMIT 0` 명령으로 테이블 생성 가능
        - 인덱스 생성 X
        - `CREATE TABLE ... LIKE` 명령으로 구조가 같은 테이블 생성 가능
- `DROP TABLE` 로 테이블 삭제

## 11.7.5 칼럼 변경

- 테이블이 큰 경우라면 가능한 테이블의 마지막 칼럼으로 추가하는 것이 좋음
- **칼럼 이름 및 타입 변경**
    - 이름 변경
        - `INSTANT` 작업으로 빠르게 완료
    - INT에서 VARCHAR로 변경
        - `COPY` 알고리즘 필요 및 쓰기 작업 불가
    - VARCHAR의 길이를 늘리기
        - 테이블의 리빌드가 필요할 수도 있고 아닐 수도 있음(사이즈에 따라 다름)
    - VARCHAR의 길이를 줄이기
        - `COPY` 알고리즘 필요 및 쓰기 작업 불가

## 11.7.6 인덱스 변경

- `ALTER TABLE ADD INDEX` 의 형태로 인덱스 추가
- `SHOW INDEXES` 명령이나 `SHOW CREATE TABLE` 명령으로 인덱스 목록 조회
- `ALTER TABLE RENAME INDEX` 의 형태로 인덱스 이름 변경
- `ALTER TABLE ALTER INDEX INVISIBLE(VISIBLE)` 의 형태로 인덱스 가시성 변경
    - **`INVISIBLE`**
        - 삭제는 하지 않고 해당 인덱스를 사용하지 않도록 함
    - **`VISIBLE`**
        - 다시 해당 인덱스를 사용하도록 변경
- `ALTER TABLE ... DROP INDEX ...` 명령으로 인덱스 삭제

## 11.7.7 테이블 변경 묶음 실행

- 같은 알고리즘을 사용하는 스키마 변경 작업은 모아서 실행하는 것이 효율적

## 11.7.8 프로세스 조회 및 강제 종료

- `SHOW PROCESSLIST` 명령으로 현재 어떤 쿼리를 실행중인지 확인 가능
- `KILL` 명령으로 특정 스레드에서 실행중인 쿼리나 커넥션 자체를 강제 종료 할 수 있음

## 11.7.9 활성 트랜잭션 조회

- `information_schema.innodb_trx` 테이블을 통해 트랜잭션 목록 확인 가능

# 11.8 쿼리 성능 테스트

## 11.8.1 쿼리의 성능에 영향을 미치는 요소

- **운영체제의 캐시**
    - 운영체제의 캐시 삭제 명령을 실행하고 테스트 하는 것이 좋음
- **MySQL 서버의 버퍼 풀(InnoDB 버퍼 풀과 MyISAM의 키 캐시)**
    - MySQL 서버를 재시작해 키 캐시나 버퍼 풀을 초기화
    - InnoDB의 경우 `innodb_buffer_pool_load_at_startup` 시스템 변수를 `OFF` 로 설정한 후 재시작
- **독립된 MySQL 서버**
- **쿼리 테스트 횟수**
    - 보통 6~7번 실행 후 처음 한두번의 결과는 버리고 나머지 결과의 평균값을 기준으로 비교하는 것이 좋음
