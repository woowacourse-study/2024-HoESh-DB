## 개요
### 파티션 사용이유
 - 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 큰 경우
 - 주기적인 삭제 작업이 필요한 경우
 - 이력 데이터 효율적인 관리(삭제에 용이하다)  

### MySQL 파티션의 내부 처리
- INSERT
	- 파티션 키인 reg_date 칼럼의 값으로 적절한 파티션을 결정한다.
- UPDATE
	- 파티션 키가 있는 경우 빠르게 찾을 수 있지만 파티션 키가 없는 경우 전체 파티션을 탐색해야한다.
	- 파티션 키 칼럼이 변경될 때는 삭제하고 저장한다.
- 검색
	- 파티션 선택 가능 + 인덱스 효율적 사용 가능
		- 파티션의 인덱스만 레인지 스캔
	- 파티션 선택 불가 + 인덱스 효율적 사용 가능
		- 파티션의 개수만큼 인덱스 레인지 스캔 수행
	- 파티션 선택 가능 + 인덱스 효율적 사용 불가
		- 대상 파티션 풀 테이블 스캔
	- 파티션 선택 불가 + 인덱스 효율적 사용 불가
		- 모든 파티션 풀 테이블 스캔
- 인덱스 스캔과 정렬
	- 파티션 단위로 인덱스 생성
	- 파티션 별로 읽으면서 우선순위 큐에 저장한다.
- 파티션 프루닝
	- 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것은 실행계획에서 배제하는 것

## 주의사항
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야한다.
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스이다. 파티션 개별로 인덱스를 변경하거나 추가할 수 없다.
- 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있다.
- 최대 8192개의 파티션을 가질 수 있다.
- 파티션 테이블에서는 외래키를 사용할 수 없다.
- 전문 검색 인덱스나 쿼리를 사용할 수 없다.
- 공간 데이터를 저장하는 칼럼 타입은 파티션 테이블에서 사용할 수 없다.
- 임시 테이블은 파티션 기능 사용 불가

## MySQL 파티션의 종류
- 레인지 파티션
	- 파티션 키의 연속된 범위로 파티션을 정의하는 방법
	- 용도
		- 날짜 기반으로 데이터 누적되거나 년,월,일 단위로 분석하고 삭제할 때
		- 범위 기반으로 파티션을 균등하게 나눌 수 있을 때
		- 파티션 키 위주로 검색이 자주 실행될 때
		- 큰 테이블을 작은 크기의 파티션으로 분리
		- 필요한 파티션만 접근
		- 가장 오래된 파티션 순서로만 삭제할 수 있다.
- 리스트 파티션
	- 파티션 키 값 하나하나를 리스트로 나열해야 한다.
	- 용도
		- 파티션 키값이 코드 값이나 카테고리와 같이 고정적일 때
		- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
		- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때
		- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
		- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 없다.
- 해시 파티션
	- 해시 함수에 의해 레코드가 저장될 파티션을 선택한다.
	- 용도
		- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
		- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때
- 키 파티션
	- MD5() 함수를 이용해 해시값을 계산하고 MOD 연산을 해서 분배한다.



