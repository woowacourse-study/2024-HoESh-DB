### Mysql 서버
- MySQL 엔진 : 머리 역할
	- 커넥션 핸들러
	- SQL 인터페이스, 파서, 옵티마이저, 캐시, 버퍼
	- GROUP BY나 ORDER BY 같은 처리도 한다.
- 스토리지 엔진 : 손발 역할 
	- 종류
		- InnoDB
		- MyISAM
	- 데이터를 디스크에 저장하거나 읽어오는 역할
	
- Mysql 엔진이 스토리지 엔진을 조정하기 위해서는 핸들러를 사용해야한다.
### MySQL 스레드
- 포그라운드 스레드(사용자 스레드)
	- 역할
		- Mysql 서버에 접속된 클라이언트 수 만큼 존재
	- 특징
		- MyISAM : 디스크 쓰기 작업까지 처리
		- InnoDB : 데이터 버퍼와 캐시까지만 포그라운드 스레드가 처리
- 백그라운드 스레드(디스크 읽기, 쓰기 작업)
	- 역할
		- 인서트 버퍼 병합
		- 디스크에 로그 기록
		- InnoDB 버퍼 풀 데이터를 디스크 기록
		- 디스크에서 버퍼로 읽기
		- 잠금이나 데드락 모니터링
	- 특징
		- InnoDB
			- 디스크 쓰기 작업을 버퍼링해서 일괄 처리한다.
			- 디스크에 완전히 저장될 때까지 기다리지 않아도 된다.
		- MyISAM
			- 버퍼링 기능을 사용하지 않는다.
### 메모리 할당
- 글로벌 메모리 영역
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼
	- 모든 스레드에 의해 공유된다.
- 로컬 메모리 영역
	- 정렬 버퍼
	- 조인 버퍼
	- 바이너리 로그 캐시
	- 네트워크 버퍼
	- 세션 메모리 영역, 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
	- 공유되지 않는다.

-> 정렬이나 조인 버퍼는 스레드마다 필요하지만 InnoDB 버퍼는 여러 쓰레드가 공유해서 쓸 수 밖에 없다.

#### 쿼리 실행 구조
- 쿼리파서
	- 쿼리를 토큰으로 분리 후 트리 형태로 변환
	- 문법 오류 처리
- 전처리기
	- 트리의 문제점 확인
	- 테이블 명, 컬림 등 존재 여부, 권한 확인
- 옵티마이저
	- 저렴한 비용으로 빠르게 처리하는 방법 결정
- 실행 엔진
	- 핸들러를 실행계획에 따라 연결시키는 역할
- 핸들러(스토리지 엔진)
	- 디스크에 읽기/쓰기 역할

##### 쿼리 캐시
- MySQL8.0 부터 제거되었다.
- 데이터 변경시 캐시를 수정하는 처리가 동시성 성능 저하를 유발하기 때문이다.

### InnoDB 스토리지 엔진 아키텍처
- 레코드 기반의 잠금 제공
- 높은 동시성 처리가 가능하고 안정적이면 성능이 뛰어나다. 
- primary 키를 기준으로 클러스터링(군집)되어 저장된다.
- 세컨더리 인덱스보다 primary 키가 선택될 확률이 높다.
#### 외래키 지원
- 데이터 체크가 필요하여 잠금이 전파되고 데드락이 발생할 때가 많아 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.
- 수동 데이터 적재나 스키마 변경에 불편하다.
#### MVCC(Multi Version Concurrency Control)
- UPDATE 문 실행 후 InnoDB 버퍼 풀에 쓰기전에 언두로그에 이전 데이터를 저장해둔다. 이를 이용하여 2개의 버전을 유지할 수 있다. 이 버전차이를 사용하여 격리 수준에 따라 보여주는 데이터를 다르게 할 수 있다.
-> 트랜잭션이 길어지면 언두 로그가 커져 메모리가 부족해진다.
#### 잠금 없는 일관된 읽기
- 언두 로그를 사용하여 잠금을 대기하지 않고 바로 실행할 수 있다.
#### 자동 데드락 감지
- 잠금 대기 목록을 list로 관리한다.
- 잠금 대기 그래프를 검사하여 교착상태에 있는 트랜잭션 중 언두로그가 적은 트랜잭션을 강제 롤백시킨다.
- 동시 처리 스래드가 많아지면 데드락 감지 스레드가 느려진다.
	- innodb_deadlock_detect OFF로 데드락 감지 스레드를 끌 수 있다.
	- innodb_lock_wait_timeout 시스템 변수 활성화로 자동 요청실패처리를 할 수 있다.
#### 자동화된 장애 복구
innodb_force_recovery 설정값 변경으로 복구를 시도할 수 있다.
- 로그 파일 손상 : 6
- 테이블의 데이터 파일 손상 : 1
#### InnoDB 버퍼 풀
- 데이터 파일 or 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 지연으로 일괄작업을 해주는 버퍼
	- 랜덤한 디스크 작업 횟수 감소
- 버퍼풀의 크기를 동작으로 조절할 수 있다.
- 구조(3개의 페이지로 관리된다.)
	- LRU(Least Recently Used) : 한 번 읽어온 페이지를 메모리에 유지하여 디스크 읽기를 최소화한다. 
		- 오래 사용되지 않으면 삭제된다.
	- Flush : 디스크로 동기화되지 않은 데이터를 가진 페이지의 변경이 이루어 졌을 때 관리한다.
	- Free : 실제 사용자 데이터가 채워지지 않은 비어있는 페이지 목록
- 디스크의 데이터가 버퍼 풀에 적재되어있는 워밍업상태에서 성능이 10배 정도 빠르다.

#### Double Write Buffer
플러시 중 비정상적인 종료로 페이지를 복수할 수 없을 수 있다.
이를 위해  Double Wrte Buffer에 기록을 해둔다.

#### 언두 로그
이전 버전의 백업된 데이터
- 트랜잭션 보장
	- 언두로그의 백업 데이터로 롤백한다.
- 격리 수준 보장
	- 격리 수준에 맞게 백업된 데이터를 반환한다.
-  UPDATE와 DELETE는 MVCC와 데이터 롤백에 사용되지만 INSERT는 데이터 롤백에만 사용된다.

#### 체인지 버퍼
데이터가 INSERT or UPDATE 시 인덱스도 업데이트해야한다.
인덱스 페이지가 버퍼 풀에 없으면 디스크에서 읽어와서 수행해야한다.
즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다.
이때 사용하는 임시 메모리 공간이 체인지 버퍼.

#### 리두 로그와 로그 버퍼
리두로그 : 쓰기 지연을 위한 버퍼
비정상 종료 시 리두로그로 상태 복구를 한다.
- 커밋됐지만 데이터파일 기록 X : 리두로그 붙여넣기
- 롤백됐지만 데이터파일 이미 기록 : 언두로그 붙여넣기, 리두로그 롤백 상태 확인
리두 로그는 기본으로 활성화 되어있어 항상 디스크로 기록된다.

#### 어댑티브 해시 인덱스
InnoDB에서 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
B-Tree 를 거치지 않고 키-값 형태로 바로 접근할 수 있게 하여 성능을 향상시킨다.
데이터 페이지를 메모리(버퍼 풀) 내에서 접근하는 것을 빠르게 만든다.
- 성능에 도움이 되는 경우
	- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우
	- 디스크 읽기가 많지 않은 경우
	- 동등 조건 검색(=, in)이 많은 경우
	- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
- 성능에 도움이 되지 않는 경우
	- 디스크 읽기가 많은 경우
	- 특정 패턴의 쿼리가 많은 경우(조인 or LIKE)
	- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
 
##### 질문
- 스레드 캐시와 스레드 풀은 같은 의미인가?
- 언두 로그, 리두 로그는 메모리에 저장되있는 건가? 아니면 디스크에도 저장된 건가?
	- 리두 로그는 쓰기 지연을 위한건데 디스크에 저장해두면 의미가 없는 거 아닌가?

##### 퀴즈
- InnoDB 버퍼 풀에 쓰는 것은 포그라운드 스레드일까? 아니면 백그라운드 스레드일까?
- InnoDB 버퍼 풀을 사용하는 이유가 뭘까요?

##### 생각
JPA의 영속성 컨텍스트의 역할을 하는 것이 Innodb 버퍼 풀 인듯?


#### MySQL 아키텍처를 이렇게 구조한 이유
- 읽기 성능 (버퍼 풀, MVCC(잠금X), 어댑티브 해시 인덱스)
- 쓰기 성능 (리두 로그 버퍼)
- 동시성 (MVCC(언두 로그))
- 확장성 (컴포넌트)
