# OT

- **MySQL 서버**
    - **MySql 엔진**
        - 사람의 머리 역할
    - **스토리지 엔진**
        - 사람의 손발 역할
        - 핸들러 API를 만족하면 누구든 스토리지 엔진을 구현하여 MySQL 서버에 추가해서 사용 가능

# 4.1 MySQL 엔진 아키텍처

## 4.1.1 MySQL의 전체 구조

- **MySql 엔진**
    - 요청된 SQL 문장을 분석하거나 최적화
    - 구성
        - **커넥션 핸들러**
        - **SQL 파서**
        - **전처리기**
        - **옵티마이저**
- **스토리지 엔진**
    - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어온다.
- MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용 가능
- 테스트에 사용할 스토리지 엔진 지정 방법

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

- **핸들러 API**
    - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데 해당 요청을 핸들러(Handler) 요청이라 부르며, 이때 사용하는 API를 핸들러 API라고 부른다.
    - 핸들러 API를 통해 얼만큼의 작업을 했는지 확인하는 명령어
    
    ```sql
    SHOW GLOBAL STATUS LIKE 'HANDLER%';
    ```
    

## 4.1.2 MySQL 스레딩 구조

- **포그라운드 스레드(클라이언트 스레드)**
    - 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
    - 각 클라이언트가 요청하는 쿼리 문장을 처리
    - 클라이언트가 작업을 마치고 커넥션을 종료하면 해당 커넥션의 스레드는 다시 스레드 캐시로 돌아감
        - 스레드 캐시에 일정 개수 이상의 스레드가 대기 중이면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 함
    - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴
    - 버퍼나 캐시에 없으면 직접 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
    - **MyISAM**
        - 디스크 쓰기 작업까지 포그라운드 스레드가 처리
    - **InnoDB**
        - 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리
        - 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
- **백그라운드 스레드**
    - InnoDB의 경우 여러 가지 작업이 백그라운드로 처리
    - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
    - 로그를 디스크로 기록하는 스레드
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 서버에서 실행 중인 스레드 목록은 performance_schema 데이터베이스의 threads 테이블을 통해 확인 가능

```sql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id;
```

## 4.1.3 메모리 할당 및 사용 구조

- **글로벌 메모리 영역**
    - 모든 스레드에 의해 공유
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
- **로컬 메모리 영역(세션 메모리 영역)**
    - 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.
    - 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우 MySQL이 메모리 공간을 할당하지 않을 수도 있다.
    - 정렬 버퍼(Sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델

- 기본 제공 스토리지 엔진 이외에 부가적인 기능을 더 제공하는 스토리지 엔진
- MySQL에서 쿼리 실행 과정 중 마지막 **데이터 읽기/쓰기** 작업만 스토리지 엔진에 의해 처리
- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.
- 스토리지 엔진 확인 명령어

```sql
SHOW ENGINES;
```

- 플러그인 확인 명령어

```sql
SHOW PLUGINS;
```

## 4.1.5 컴포넌트

- MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 만듬
- 플러그인 아키텍처 단점
    - 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음
    - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
    - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- 설치된 컴포넌트 확인 명령어

```sql
SELECT * FROM mysql.component;
```

## 4.1.6 쿼리 실행 구조

- **쿼리 파서**
    - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조(**파서 트리**)로 만들어 내는 작업
    - 기본 문법 오류 발견
- **전처리기**
    - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는 지 확인
    - 각 토큰을 테이블 이름이나 칼럼 이름, 내장 함수와 같은 객체와 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인
- **옵티마이저**
    - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정
- **실행 엔진**
    - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
- **핸들러(스토리지 엔진)**
    - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당

## 4.1.7 복제

## 4.1.8 쿼리 캐시

- SQL의 실행 결과를 메모리에 캐시
- 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환
- but, 테이블의 데이터가 변경되면 캐시에 저장된 결과 중 변경된 테이블과 관련된 것들은 모두 삭제해야 함
    - 심각한 동시 처리 성능 저하를 유발
    - 따라서 MySQL 8.0에서 쿼리 캐시 제거

## 4.1.9 스레드 풀

- MySQL 서버 엔터프라이즈 에디션에서 제공
- MySQL 커뮤니티 에디션에선 Percona Server에서 플러그인 형태로 제공
- 스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있도록 함
    - 서버의 자원 소모를 줄이는 것이 목적
- 스레드 그룹의 개수는 CPU 코어의 개수와 맞추는 것이 CPU 프로세스 친화도를 높이는 데 좋다.
- 너무 많아도 비효율…
- 스레드 그룹의 모든 스레드가 일을 처리하고 있으면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할 지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단
    - 스레드 풀의 타이머 스레드는 주기적으로 스레드 그룹의 상태를 체크하여 `thread_pool_stall_limit` 시스템 변수에 정의된 밀리초만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성하여 스레드 그룹에 추가
    - 전체 스레드 풀에 있는 스레드의 개수는 `thread_pool_max_threads` 시스템 변수에 설정된 개수를 넘을 수 없음
    - 응답 시간에 민감한 서비스라면 `thread_pool_stall_limit` 시스템 변수를 적절히 낮춰야 함
    - `thread_pool_stall_limit` 을 0에 가까운 값으로 설정하는 것은 비추천
- Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 사용하여 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능 제공
- 잠금 경합(특정 세션이 작업을 진행하지 못하고 멈춰 선 상태)을 낮춰 전체적인 처리 성능을 향상

## 4.1.10 트랜잭션 지원 메타데이터

- **메타 데이터(데이터 딕셔너리)**
    - 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 의미
- 기존에는 파일 기반으로 관리
- 파일 기반의 메타 데이터는 생성 및 변경 작업에 트랜잭션 지원X
    - 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남게 되는 문제 발생
- MySQL 8.0부터는 메타 데이터를 InnoDB의 테이블에 저장하도록 개선
- **시스템 테이블**
    - MySQL 서버가 작동하는 데 기본적으로 필요한 테이블

# 4.2 InnoDB 스토리지 엔진 아키텍처

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스트링되어 저장됨(프라이머리 키 값 순서)

<aside>
👉 **클러스터링**

서로 유사한 속성을 갖는 데이터를 같은 군집으로 묶어주는 작업

</aside>

## 4.2.2 외래 키 지원

- 외래 키 체크 작업을 일시적으로 멈추는 명령어

```sql
SET foregin_key_checks=OFF;

-- // 작업 실행

SET foregin_key_checks=ON;
```

## 4.2.3 MVCC(Multi Version Concurrency Control)

- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공함에 있다.
- InnoDB는 언두 로그(Undo log)를 이용하여 MVCC를 구현
- **Multi Version**
    - 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨
    - `COMMIT` 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만든다.
    - 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해 버린다.

## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- MVCC를 활용해 잠금을 걸지 않고 읽기 작업을 수행
- 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음

## 4.2.5 자동 데드락 감지

- 잠금 대기 목록을 그래프 형태로 관리
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 강제 종료
    - 판단 기준은 언두 로그의 양
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상
- 만약 동시 처리 스레드가 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
    - `innodb_deadlock_detect` 를 `OFF` 로 설정하면 데드락 감지 스레드 작동 X
    - 이때, `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패 후 에러 메시지 반환

## 4.2.6 자동화된 장애 복구

- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행
- 복구될 수 없는 손상이 있으면 자동 복구를 멈추고 MySQL 서버는 종료됨
- `innodb_force_recovery` 시스템 변수를 설정하여 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있음

## 4.2.7 InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함
- `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있음
- 구조
    - **LRU(Least Recently Used) 리스트**
        - 엄밀하게는 LRU와 MRU 리스트가 결합된 형태
        - **Old 서브리스트** 영역은 LRU
        - **New 서브리스트** 영역은 MRU
        - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지하여 디스크 읽기를 최소화
        - InnoDB 스토리지 엔진에서 데이터를 찾는 과정
            - 필요한 레코드가 저장된 페이지가 버퍼 풀에 있는지 검사
            - 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
            - 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
            - 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여
                - 만약 오랫동안 사용되지 않으면 나이가 오래되고 해당 페이지는 버퍼 풀에서 제거
                - 만약 사용되면 나이가 초기화 되어 다시 젊어짐
            - 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
    - **플러시(Flush) 리스트**
        - 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
    - **프리(Free) 리스트**
        - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
        - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
- **추가 학습 키워드**
    - 버퍼 풀과 리두 로그 관계
    - 버퍼 풀 플러시

## 4.2.8 Double Write Buffer

- InnoDB에서 여러 개의 더티 페이지를 디스크로 플러시 할 때, 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록
- 재시작 될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사

## 4.2.9 언두 로그

- **언두 로그**
    - 트랜잭션과 격리 수준을 보장하기 위해 별도로 백업한 DML로 변경되기 이전 버전의 데이터
- **트랜잭션의 격리 수준**
    - 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준

## 4.2.10 체인지 버퍼

- 변경해야 할 인덱스 페이지가 버퍼 풀에 없으면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키는데 이때 사용하는 임시 메모리 공간
    - 유니크 인덱스는 체인지 버퍼를 사용할 수 없음
    - `innodb_change_buffering` 시스템 변수를 통해 작업의 종류별로 체인지 버퍼를 활성화 가능

## 4.2.11 리두 로그 및 로그 버퍼

- 하드웨어나 소프트웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
- 대부분의 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록
    - 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 정료되기 직전의 상태로 복구
- 데이터의 변경 발생시 리두 로그 버퍼, 리두 로그 버퍼에 일정 크기 이상 저장 되면 리두 로그 파일로 이동

<aside>
💡 **ACID**

데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 꼭 필요한 4가지 요소

A: Atomic, 트랜잭션은 원자성 작업이어야 함
C: Consistent, 일관성
I: Isolated, 격리성
D: Durable, 한 번 저장된 데이터는 지속적으로 유지돼야 함

</aside>

## 4.2.12 어댑티브 해시 인덱스

- 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- `innodb_adaptive_hash_index` 시스템 변수를 이용해 어댑티브 해시 인덱스 기능을 활성화하거나 비활성화 할 수 있음
- 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고, 버퍼 풀에 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보 사라짐
- 어떤 테이블의 인덱스가 어댑티브 해시 인덱스에 적재되어 있을 때, 해당 테이블을 삭제하거나 변경하면 해당 테이블의 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야 함
- **추가 학습 키워드**
    - B-Tree 인덱스

## 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- **MyISAM**
    - MySQL 8.0부터 MyISAM 스토리지 엔진만이 가지는 장점이 없어 이후에 사라질 것으로 예상
- **MEMORY 스토리지 엔진**
    - 동시 처리 성능이 InnoDB를 따라가지 못하여 향후 버전에서 제거될 것으로 예상

# 4.4 MySQL 로그 파일

## 4.4.1 에러 로그 파일

- MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일

## 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

- MySQL 서버에서 실행되는 쿼리 전체 목록
- 슬로우 쿼리 로그와는 다르게 실행되기 전에 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록

## 4.4.3 슬로우 쿼리 로그

- MySQL이 쿼리를 실행한 후, 실제 소요된 시간을 기준으로 슬로우 쿼리 로그에 기록할 지 여부를 판단
