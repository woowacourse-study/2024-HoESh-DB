# 5.1 트랜잭션

## 5.1.1 MySQL에서의 트랜잭션

- 트랜잭션이란  논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해주는 것이다.

MyISAM과 InnoDB의 트랜잭션 동작 차이점을 살펴보자.

PK가 id이고 db에 id=3인 값을 insert한다. 그리고 다시 1,2,3을 동시에 insert 하면 MyISAM은 1과 2는 데이터를 삽입하고 3은 PK 중복으로 인해 삽입하지 않는다. 하지만 InnoDB는 1,2도 삽입하지 않는다. 3을 삽입하는 도중에 오류가 발생했기 때문에 이전에 실행된 것들도 롤백해준다. 

MyISAM에서는 발생하는 문제를 부분 업데이트(Partial Update) 문제라고 한다.

## 5.1.2 주의사항

네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다. 아니라면 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 발생할 수 있다.

트랜잭션의 범위를 최소화해야한다. 

# 5.2 MySAL 엔진의 잠금

- 스토리지 엔진 레벨
    - 스토리지 엔진 간 상호 영향을 미치지 않음
- MySQL 엔진 레벨
    - 모든 스토리지 엔진에 영향을 미침
    - 테이블 락: 테이블 데이터 동기화를 위한 락
    - 메타데이터 락: 테이블 구조를 잠그는 락
    - 네임드 락: 사용자의 필요에 맞게 사용할 수 있는 락

## 5.2.1 글로벌 락

- FLUSH TABLES WITH READ LOCK 명령으로 획득
- 글로벌 락이 걸리면 DDL이나 DML 문장 실행시 대기 걸림
- 영향을 미치는 범위는 MySQL 서버 전체이며 작업 대상 테이블이나 db가 다르더라도 동일하게 영향을 미침

**백업 락**

백업락을 획득하면 아래와 같은 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

반면에 일반적인 데이터 변경은 허용한다. 

## 5.2.2 테이블 락

- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음
- 명시적 락은 LOCK TABLES table_name [ READ | WRITE ] 로 획득
- UNLOCK TABLES 명령으로 반납
- 묵시적 락은 MyISAM이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
- innodb 테이블은 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다.
- 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

## 5.2.3 네임드 락

- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 대상은 테이블이나 레코드 또는 auto_increment 같은 db객체가 아니라 사용자가 지정한 문자열(String)이다
- db 서버 1대에 5대의 웹서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건 처럼 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 해결가능하다.

## 5.2.4 메타데이터 락

- 메타데이터 락은 db 객체(대표적으로 테이블이나 뷰)의 이름이나 구조를 변경하는 경우 획득하는 잠금

# 5.3 InnoDB 스토리지 엔진 잠금

## 5.3.1 InnoDB 스토리지 엔진의 잠금

- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공함
- 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락이 레벨업되는 경우(락 에스컬레이션)는 없다.

### 5.3.1.1 레코드 락

- 레코드 자체만을 잠그는 것
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
- InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락 또는 갭 락을 사용하지만 PK 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해ㅓㅅ만 락을 건다.

### 5.3.1.2 갭 락

- 갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어

### 5.3.1.3 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- innoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
- 하지만 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하낟.
- 가능하다면 바이너리 로그 포맷을 row 형태로 바꿔 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

### 5.3.1.4 자동 증가 락

- auto_increment 락은 insert와 replace 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요
- update, delete 등의 쿼리에는 걸리지 않음
- 동시에 insert가 실행되는 경우 하나의 쿼리가 auto_increment 락을 걸면 나머지 쿼리는 auto_increment 락을 기다려야 한다.
- 명시적으로 획득하고 해제하는 방법은 없다.
- 자동 증가 값이 한번 증가하면 절대 줄어들지 않는 이유가 auto_increment 잠금을 최소화하기 위해서다.
- insert 쿼리가 실패했더라고 한 번 증가된 auto_increment 값은 다시 줄어들지 않는다.

## 5.3.2 인덱스와 잠금

- innoDB는 레코드를 잠그는 것이 아닌 인덱스 레코드를 잠근다.
- 테이블에 인덱스가 걸려있지 않다면 테이블을 풀 스캔하면서 update 작업을 하는데 때문에 테이블 전체에 레코드를 잠그게 된다.
- MySQL의 InnoDB에서 인덱스 설계가 중요한 이유가 여기 있다


# 5.4 MySQL의 격리 수준

|  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 없음 | 발생 | 발생 |
| REPEATABLE READ | 없음 | 없음 | 발생(innoDB는 없음) |
| SERIALIZABLE | 없음 | 없음 | 없음 |

## 5.4.1 READ UNCOMMITTED

- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상인 더티 리드가 발생
- mYsql을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용할 것을 권장

## 5.4.2 READ COMMITTED

- 더티 리드 발생하지 않음
- 동일한 트랜잭션 내에서 똑같은 select 쿼리가 실행됐을 때 항상 같은 쿼리가 나오는 게 아닌 NON-REPEATABLE READ 문제 발생

## 5.4.3 REPEATABLE READ

- MySQL InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 더티 리드와 논 리피터블 리드 문제가 발생하지 않는다.
- MVCC를 사용해 COMMIT 되기 전에 데이터를 보여준다.
- READ COMMITTED와 REPEATABLE READ의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.
- 모든 INNODB의 트랜잭션은 고유한 트랜잭션 번호를 가지며 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.
- 그리고 언두 영역의 백업된데이터는 INNODB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제
- REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.

- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상을 PHANTOM READ라고 한다.
- SELECT … FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다.
- 그래서 SELECT … FOR UPDATE 혹은 SELECT … LOCK IN SHARE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 되는 것이다.

## 5.4.4 SERIALIZABLE

- 가장 단순한 격리 수준임과 동시에 엄격한 격리 수준
- 때문에 동시 처리 성능이 떨어진다.
- 읽기 작업도 공유 잠금을 획득해야한 하며 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- 시리얼라이져블은 일반적인 DBMS에서 일어나는 팬텀 리드 문제가 발생하지 않는다.
- INNODB 스토리지 엔진은 갭 락과 넥스트 키 락 덕분에(how) REAPETABLE READ 격리 수준에서도 이미 팬텀리드가 발생하지 않기 때문에 굳이 쓸 필요가 없음
