## 요약
잠금 : 동시성을 제어하기 위함
트랜잭션 : 정합성을 보장하기 위함

### 트랜잭션
- 트랜잭션은 하나의 쿼리에서도 동작한다. (ex: 여러 컬림 insert 시 하나만 insert 실패해도 롤백된다.)
- 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화하자
	- 커넥션이 길어지면 여유 커넥션 수가 줄어들고 커넥션을 기다려야하는 상황이 온다.
	- 외부와 통신하는 작업은 트랜잭션 밖에 있는 것이 좋다. 서버와 통신할 수 없는 상황이 오면 웹, DBMS 서버까지 위험해 질 수 있다.
	- 단순 조회는 트랜잭션이 필요없다.
### 잠금
#### 글로벌 락
- 범위 : MySQL 서버 전체
- 테이블이나 데이터베이스가 다르더라도 동일하게 영향
- InnoDB는 트랜잭션을 지원하기 때문에 모든 데이터 변경을 멈출 필요가 없다.(MVCC를 사용하기 때문)
#### 테이블 락
- 묵시적, 명시적 획득
- InnoDB는 레코드 기반의 잠금을 지원하여 테이블 락이 걸리지 않는다.
- 스키마를 변경하는 경우에만 영향을 미친다.
#### 네임드 락
- 명시적 획득
- 특정 문자에 락을 걸 수 있다.
- 잘 사용안한다.
#### 메타데이터 락
- 묵시적 획득
- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 락

### InnoDB 스토리지 엔진 잠금

#### InnoDB 스토리지 엔진의 잠금
- 레코드 락 : 인덱스의 레코드를 잠금
	- primary 키 or 유니크 인덱스에 의한 변경 작업은 레크드 자체에 대해서만 락을 건다.
- 갭 락 : 레코드와 인접학 레코드 사이의 간격만 잠근다.
	- 레코드와 레코드 사이에 새로운 레코드 생성을 제한한다.
- 넥스트 키 락 : 레코드 락 + 갭 락
	- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
	- REAPTABLE_READ 에서 팬텀 READ를 막을 수 있다.
- 자동 증가 락 : AUTO_INCREMENT 가 있는 테이블 잠금
	- INSERT, REPALCE 시 걸린다.
#### 인덱스와 잠금
- InnoDB는 인덱스에 잠금을 걸기 때문에 UPDATE 시 인덱스의 조건에 해당하는 레코드들이 전부 잠금에 걸린다.
	- 인덱스가 없으면 테이블을 풀스캔하기 때문에 모든 레코드에 잠금이 걸린다.
### MySQL 격리 수준 
|                  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| ---------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITTED | O          | O                   | O            |
| READ COMMITTED   | X          | O                   | O            |
| REPEATABlE READ  | X          | X                   | O(InnoDB X)  |
| SERIALIZABLE     | X          | X                   | X            |
#### READ UNCOMMITTED
- 커밋되지 않은 내용을 읽는다.
#### READ COMMITTED
- Oracle 기본 격리 수준
- 변경 이전 내역이 언두 로그에 남아있기 때문에 Dirty Read를 막는다.
- 다시 읽었을 때 그 사이에 커밋이 발생하면 값이 바뀐다.(NON-REPEATABLE READ
#### REPEATABLE READ
- MySQL InnoDB 기본 격리 수준
- 커밋이 되어도 언두로그에 남아 있기 때문에  변경 이전 레코드를 읽어온다.
- 트랜잭션 번호를 기준으로 현재 트랜잭션 번호보다 작은 번호에서 변경한 것만 보인다.
- 범위 조회의 경우 결과가 다를 수 있다. (PHANTOM READ)
	- 추가되는 레코드는 잠금이 안걸려있다.
	- 언두로그에는 잠금을 걸 수 없기 때문이다.
- InnoDB는 갭락과 넥스트 키 락 으로 REPEATABLE READ 에서도 발생하지 않는다. \
	- 범위 조회시 조회한 레코드 외에도 인접한 레코드까지 락을 걸어 INSERT를 막는다.
#### SERIALIZABLE
- 읽기 작업도 공유 잠금을 획득해야한다.
- 한 트랜잭션이 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 접근할 수 없다.
- PHANTOM READ가 발생하지 않는다.
	- InnoDB는 갭락과 넥스트 키 락 으로 REPEATABLE READ 에서도 발생하지 않는다. 
	- (select ... for share 는 발생한다.)

## 질문 
1. REPEATABLE READ에서 갭락과 넥스트 키 락으로 어떻게 PHANTOM READ를 막는가?


