## 8.1 디스크 읽기 방식
데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.
### 8.11 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
데이터베이스 서버에서는 항상 디스크 장치가 병목 -> 전자식 저장 매체인 SSD가 출시되었다. 
SSD는 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다. 
→ 요즘은 DMBS용으로 사용할 서버에는 대부분 SSD를 채택하고 있다. 

SSD의 장점
- 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르다. 
	- 데이터베이스 서버에서 랜덤  I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이다. 

### 8.1.2 랜덤 I/O와 순차 I/O
![image](https://github.com/user-attachments/assets/cefdaab2-06fd-40bb-885c-1de3c725247b)
순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 요청
랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청
→ 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
따라서, 여러번 쓰기 or  읽기 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 크다.

## 8.2 인덱스란?
- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key - Value pair)으로 삼아 인덱스를 만들어 두는 것이 다. 
- DBMS의 인덱스도 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- SortedList
	- 장점: 이미 정렬돼 있어서 원하는 값을 빠르게 찾아올 수 있다. - SELECT
	- 단점: 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느림 - INSERT, UPDATE, DELETE
→ 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.

인덱스의 역할별로 구분 - 프라이머리 키, 보조키(세컨더리 인덱스)
- 프라이머리키: 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다.

RDBMS에서 많이 사용하는 알고리즘
- B-Tree
	- 가장 일반적으로 사용되는 인덱스 알고리즘
	- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
- Hash 인덱스
	- 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
	- 값을 변형해서 인덱싱하므로 Prefix일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다. 
	- 주로 메모리 기반의 데이터베이스에서 많이 사용한다.
## 8.3 B(Balanced)-Tree 인덱스
### 8.3.1 구조 및 특성
![image](https://github.com/user-attachments/assets/92eb1415-ef8c-4488-9aef-6b8f93ea8ed5)
- 루트 노드(Root node)
- 리프 노드(Lead node)
	- 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- 브랜치 노드(Branch node)
인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
![image](https://github.com/user-attachments/assets/07206df4-f29b-497a-8922-db525604531e)
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가진다.
- InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.
	- 인데스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
### 8.3.2.1 인덱스 키 추가
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색한다.
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
	- 리프 노드가 꽉 차서 저장할 수 없을 때 → 리프 노드가 분리돼야 한다.
	→ 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 
	→ B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
### 8.3.2.2 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크를 한다.
삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
→ 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로, 디스크 I/O가 필요한 작업이다.
### 8.3.2.3 인덱스  키 변경
인덱스의 키 값은, 그 값에 따라 저장될 리프 노드의 위치가 결정된다. 따라서 B-Tree 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.
- B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
- InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리 될 수 있다.
	- 세컨더리 인덱스 페이지가 버퍼풀에 없을 때, 세컨더리 인덱스 변경사항을 버퍼링하면 I/O 작업을 피할 수 있다. 버퍼링된 변경사항은 나중에 다른 READ 작업에 의해 버퍼풀에서 페이지가 LOAD 될 때 Merge된다.
### 8.3.2.4 인덱스 키 검색
트리탐색: 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행한다. 
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 
- 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다. 
- 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 B-Tree의 빠른 검색 기능을 사용할 수 없다.
### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스를 구성하는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수
### 8.3.3.1 인덱스 키 값의 크기
페이지(Page), 블록(Block): 디스크에 데이터를 저장하는 가장 기본 단위
DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조이다.
- MySQL의 B-Tree는 자식 노드를 몇 개 까지 가지는가?
	→ 인덱스의 페이지 크기과 키 값의 크기에 따라 결정된다.
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어난다.
- 인덱스의 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다.
	- 레코드를 위한 인덱스 크기가 커질수록 캐시해 둘 수 있는 레코드 수는 줄어든다.
### 8.3.3.2 B-Tree 깊이
B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
- 인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하다.
→ 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다.
### 8.3.3.3 선택도(기수성)
**모든 인덱스 키 값 가운데 유니크한 값의 수**
ex) 전체 인덱스 키 값은 100개인데, 그 중 유니크한 값의 수는 10개라면 기수성은 10이다.
→ 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.
### 8.3.3.4 읽어야 하는 레코드 건수
인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
- 테이블 레코드 100만 건 중 50만 건을 읽어야 할때
	- 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적인지
	- 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적인지 판단해야한다.
- 일반적인 DMBS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드를 1건 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
 → 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필터링 하는 것이 효율적이다.
### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
### 8.3.4.1 인덱스 레인지 스캔
![Pasted image 20240720172632](https://github.com/user-attachments/assets/09a5de20-54f4-419f-b00c-2fac3845aeed)
인덱스의 접근 방법 가운데 가장 대표적인 접근 방식
```SQL
SELECT * FROM employess WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 리프 노드까지 찾아 들어가, 필요한 레코드의 시작 위치를 찾는다.
- 시작할 위치를 찾으면, 리프 노드의 레코드만 순서대로 읽으면 된다.(스캔)
- 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다.

![Pasted image 20240720172922](https://github.com/user-attachments/assets/fb9024ef-84e3-444e-bcf3-5f1ba43f1f68)

- 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다.
- 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.
인덱스 레인지 스캔 단계
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.(Index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.(Index scan)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
### 8.3.4.2 인덱스 풀 스캔
**![image](https://github.com/user-attachments/assets/9b7ec759-d3a9-4be6-8a36-dfc6f8602c09)
- 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로, 인덱스만 읽는 것이 효율적이다.
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
*인덱스 풀 스캔 방식은 일반적으로 인덱스를 생성하는 목적은 아니다.

### 8.3.4.3 루스 인덱스 스캔
![Pasted image 20240720181843](https://github.com/user-attachments/assets/7d3a64d4-0b67-45b4-b682-cd27e8fa6e83)
- 듬성듬성하게 인덱스를 읽는 것
- 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태
- 일반적으로 GROUP BY 또는 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.
```SQL
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```
- dept_nodhk emp_no라는 두 개의 칼럼으로 인덱스가 생성돼 있다.
- (dept_no, emp_no) 조합으로 정렬되어 있다.
	→ dept_no 그룹별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
### 8.3.4.4. 인덱스 스킵 스캔
~~~SQL
ALTER TABLE employess ADD INDEX ix_gender_birthdate(gender, birth_date);
~~~

해당 인덱스를 사용하려면 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수다.
```SQL
-- // 인덱스를 사용하지 못하는 쿼리
mysql> SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- // 인덱스를 사용할 수 있는 쿼리
mysql> SELECT * FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
```
MySQL 8.0 버전부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔(Index skip scan) 최적화 기능이 도입됐다.

```SQL
mysql> SET optimizer_switch='skip_scan=off';

mysql> EXPLAIN 
SELECT gender, birth_day 
FROM employees 
WHERE birth_day >= '1965-02-01';
+----+-------------+-----------+------------+-------+--------------------
| id | table     | type | key                 | Extra                    |
+----+-------------+-----------+------------+-------+--------------------
|  1 | employees |index | ix_gender_birthdate | Using where; Using index |
+----+-------------+-----------+------------+-------+--------------------
```
type 칼럼이 **index** 라고 표시된 것은 인덱스를 처음부터 끝까지 모두 읽었다는 의미이다. 즉 인덱스를 비효율적으로 사용한 것이다. 


```SQL
mysql> SET optimizer_switch='skip_scan=on';

mysql> EXPLAIN 
SELECT gender, birth_day 
FROM employees 
WHERE birth_day >= '1965-02-01';
+----+-------------+-----------+------------+-------+--------------------
| id | table    | type | key                | Extra                    |
+----+-------------+-----------+------------+-------+--------------------
|  1 | employees|range | ix_gender_birthdate | Using where; Using index for skip scan |
+----+-------------+-----------+------------+-------+--------------------
```

![Pasted image 20240720201145](https://github.com/user-attachments/assets/f7f52168-006d-4dfc-9029-bc3f5697ff86)

MySQL 8.0 버전부터 도입된 인덱스 스킵 스캔을 활성화하고 실행한 결과이다.
- type 칼럼의 값이 “range”로 표시된 것은 인덱스에서 꼭 필요한 부분만 읽었다는 것을 의미한다.
- Extra 칼럼에 “Using index for skip scan” 은 ix_gender_birthdate 인덱스에 대해 인덱스 스킵 스캔을 활용해 데이터를 조회했다는 것을 의미한다.
- MySQL 옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.

gender 칼럼에 대해 가능한 값 2개를 구한 다음, 옵티마이저는 내부적으로 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행하게 된다.
```SQL
mysql> SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date >= '1965-02-01';

mysql> SELECT gender, birth_date FROM employees WHERE gender='F' AND birth_date >= '1965-02-01';
```

! 인덱스 스킵 스캔의 단점
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
	- 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다.
- 쿼리가 인덱스에 존재하는 칼럼으로 처리 가능해야 함(커버링 인덱스)
```SQL
mysql> EXPLAIN 
SELECT *
FROM employees 
WHERE birth_day >= '1965-02-01';
+----+-------------+-----------+------------+-------+--------------------
| id | table     | type | key  | rows   | Extra      |
+----+-------------+-----------+------------+-------+--------------------
|  1 | employees |ALL   | NULL | 3003653| Using where|
+----+-------------+-----------+------------+-------+--------------------
```
employees 테이블의 모든 칼럼을 조회하도록 변경했다.
인덱스에 포함된 칼럼외 나머지 칼럼도 필요하기 때문에 풀 테이블 스캔으로 실행 계획을 수립했다.

### 8.3.5 다중 칼럼(Multi-column) 인덱스
두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 한다.
![Pasted image 20240720202340](https://github.com/user-attachments/assets/adc7fb1c-b14d-4a07-94e6-519d2e9cb696)
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다. 
- emp_no 값의 정렬 순서가 빠르다고 하더라도 dept_no 칼럼의 정렬 순서가 늦다면 인덱스의 뒤쪽에 위치한다.
! 다중 칼럼 인덱스에서 인덱스 내에서 각 칼럼의 위치가 상당히 중요하며, 신중히 결정해야 한다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.
### 8.3.6.1 인덱스의 정렬
MySQL 8.0 버전부터는 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.
```SQL
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```
### 8.3.6.1.1 인덱스 스캔 방향
```SQL
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```
인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로 값을 가져올 수 있고, 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 알고 있다. 
![image](https://github.com/user-attachments/assets/162b525e-20eb-4f04-a828-d21ff50b282e)
- 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.

### 8.3.6.1.2 내림차순 인덱스
![image](https://github.com/user-attachments/assets/0ab01174-249e-4bd6-9d0b-2dcbaa968ba8)
- 오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼족으로 정렬된 인덱스
- 인덱스 정순 스캔: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스 역순 스캔: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
```SQL
mysql> SELECT * FROM t1 ORDER BY tid ASC LIMIT 12619775,1;
1 row in set (4.15 sec)

mysql> SELECT * FROM t1 ORDER BY tid DESC LIMIT 12619775,1;
1 row in set (5.35 sec)

```
- 역순 정렬 쿼리가 정순 정렬 쿼리보다 시간이 더 걸리는 것을 확인할 수 있다. 
→ InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없다.
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
	- InnoDB 페이지 내부에서 레코드들이 단방향으로만 링크를 가진 구조이다.
- 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성
### 8.3.7.1 비교 조건의 종류와 효율성
다중 칼럼 인덱스에서 각 칼럼의 순서와 칼럼에 사용된 조건이 동등 비교(“=)인지 아니면 크다(“>”) 또는 작다(“<“) 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라진다.

```SQL
mysql> SELECT * FROM dept_emp
WHERE dept_no = 'd002' AND emp_no >= 10114;
```

![image](https://github.com/user-attachments/assets/d7d20f89-5beb-4697-8a47-16954463bc21)

인덱스 생성
- 케이스 A: INDEX(dept_no, emp_no)
	- “dept_no=’d002” AND emp_no ≥ 10114인 레코드를 찾고, 이후 dept_no가 ‘d002’가 아닐 때까지 인덱스를 읽는다.
	- 작업의 범위를 줄임: 작업 범위 결정 조건
- 케이스 B: INDEX(emp_no, dept_no)
	- emp_no ≥ 10114 AND “dept_no=’d002’인 레코드를 찾고, 이후 dept_no 가 ’d002’인지 비교하는 과정을 거쳐야 한다.
	- 작업의 범위를 줄이지 못하고 거름종이 역할을 함: 필터링 조건, 체크 조건

## 클러스터링 인덱스
MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현된다. 
### 8.8.1 클러스터링 인덱스
프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다 → 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다.
- InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블
	- 프라이머리 키 기반의 검색이 매우 빠르다
	- 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다
![image](https://github.com/user-attachments/assets/f0c02f46-76f1-4d9b-b33e-765663dd2f8f)
- 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장되어있다.
	→ 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리된다.

! 프라이머리 키를 변경한 경우
```SQL
mysql> UPDATE tb_test SET emp_no=100002 WHERE emp_no=100007;
```
![image](https://github.com/user-attachments/assets/6394ba18-d104-43b9-9a41-045e8efbee4a)
3번 페이지에 있던 데이터가 2번 페이지로 이동했다. 
! 프라이머리 키가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성?
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

### 8.8.2 세컨더리 인덱스에 미치는 영향
InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다.
```SQL
mysql> CREATE TABLE emplyees (
	emp_no INT NOT_NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

mysql> SELECT * FROM employees WHERE first_name = 'Aamer';

```
- MyISAM: ix_first 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져온다.
- InnoDB: ix_first 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

### 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점
	- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
	- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버리 인덱스)
- 단점
	- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 인덱스의 크기가 커짐
	- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
	- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되지 때문에 처리 성능이 느림
	- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
**유의사항**
- 클러스터링 인덱스 키의 크기
- 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성
- 프라이머리 키는 반드시 명시할 것
- AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

## 8.9 유니크 인덱스
유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.
### 8.9.1.1 인덱스 읽기
유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이기 때문에 성능상 유니크 인덱스보다 느리지 않다.
- 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것은 아니다.
### 8.9.1.2 인덱스 쓰기
새로운 레코드 INSERT나  인덱스 칼럼 값 변경시, 인덱스 쓰기 작업이 필요함
- 유니크 인덱스의 키 값을 쓸 경우: 중복된 값이 있는지 없는지 체크하는 과정이 한단계 더 필요
	→ 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
- 유니크 인덱스에서 중복된 값 확인시 읽기 잠금, 쓰기를 할때는 쓰기 잠금을 사용 → 데드락 빈번
- 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링 하지 못함

### 8.9.2 유니크 인덱스 사용 시 주의사항
MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.

## 8.10 외래키
MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있다. 
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
**InnoDB의 외래키 관리 특징**
- 테이블의 변경(쓰기 잠금)이 발생한 경우에만 잡금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

```SQL
mysql> CREATE TABLE tb_parent (
	id INT NOT NULL,
	fd VARCHAR(100) NOT NULL, PRIMARY KEY(id)
) ENGINE=InnoDB;

mysql> CREATE TABLE tb_child (
	id INT NOT NULL,
	pid INT DEFAULT NULL, -- // parent.id 참조
	fd VARCHAR(100) DEFAULT NULL,
	PRIMARY KEY(id),
	KEY ix_parentid(pid),
	CONSTRAINT child_ibfk_1 FOREIGN KEY(pid) 
		REFERENCES tb_parent (id) ON DELETE CASCADE
) ENGINE=InnoDB;

mysql> INSERT INTO tb_parent VALUES (1, 'parent-1'), (2, 'parent-2');
mysql> INSERT INTO tb_child VALUES (100, 1, 'child-100');

```

### 8.10.1 자식 테이블의 변경이 대기하는 경우

| 작업 번호 | 커넥션 - 1                                                 | 커넥션 - 2                                    |
| ----- | ------------------------------------------------------- | ------------------------------------------ |
| 1     | BEGIN;                                                  |                                            |
| 2     | UPDATE tb_parent<br>SET fd =’changed-2’ <br>WHERE id=2; |                                            |
| 3     |                                                         | BEGIN                                      |
| 4     |                                                         | UPDATE tb_child<br>SET pid=2 WHERE id=100; |
| 5     | ROLLBACK                                                |                                            |
| 6     |                                                         | Query OK, 1 row affected                   |

- 자식 테이블의 외래 키 칼럼 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요함
- 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면, 해당 쓰기 잠금 해제시까지 대기
### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

| 작업 번호 | 커넥션 - 1                                                     | 커넥션 - 2                              |     |
| ----- | ----------------------------------------------------------- | ------------------------------------ | --- |
| 1     | BEGIN;                                                      |                                      |     |
| 2     | UPDATE tb_child<br>SET fd =’changed-100’ <br>WHERE id=100; |                                      |     |
| 3     |                                                             | BEGIN                                |     |
| 4     |                                                             | DELETE FROM tb_parent<br>WHERE id=1; |     |
| 5     | ROLLBACK                                                    |                                      |     |
| 6     |                                                             | Query OK, 1 row affected             |     |

- 부모 키를 참조하는 자식 테이블의 레코드를 변경하면, 자식 테이블의 레코드에 대해 쓰기 잠금을 획득한다.
→ 데이터베이스에서 외래 키를 물리적으로 생성하려면 잠금 경합까지 고려해 모델링을 진행하는 것이 좋다!