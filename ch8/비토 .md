# 8.1 디스크 읽기 방식

## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 순차 I/O 성능 : SSD == 하드 디스크 드라이브
- 랜덤 I/O 성능 : SSD > 하드 디스크 드라이브

## 8.1.2 랜덤 I/O와 순차 I/O

- 순차 I/O : 3개의 페이지를 디스크에 기록하기 위해 1번의 시스템 콜을 요청. 즉, 디스크의 헤드를 1번 움직임
- 랜덤 I/O : 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜을 요청. 즉, 디스크의 헤드를 3번 움직임
- 쿼리 튜닝 : 랜덤 I/O를 줄여주는 것

# 8.2 인덱스란?

- DBMS의 인덱스는 SortedList와 같은 자료 구조를 사용
- 항상 정렬된 상태로 유지
- SELECT문을 빠르게 처리할 수 있음
- INSERT, UPDATE, DELETE는 계속 정렬을 해야 하므로 처리가 느려짐
- PK를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류

# 8.3 B-Tree 인덱스

## 8.3.1 구조 및 특성

- 최상위: **루트 노드**, 중간: **브랜치 노드**, 최하위: **리프 노드**
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

- **추가**
    - 저장될 키 값을 이용해 B-Tree상의 적절한 위치 검색
    - 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
    - 리프 노드가 꽉 차서 더는 저장할 수 없으면 리프 노드가 분리됨
        - 이는 상위 브랜치 노드까지 처리의 범위가 넓어짐
        - 따라서, 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 듬
- **삭제**
    - 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료됨
- **변경**
    - 인덱스의 키 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스상의 키 값만 변경하는 것은 불가능
    - 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리됨
- **검색**
    - B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있음
    - 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없음

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- **인덱스 키 값의 크기**
    - **페이지(Page)** 또는 **블록(Block)**
        - 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
        - 데이터를 버퍼링하는 기본 단위
        - 인덱스 페이지 크기: 16KB, 인덱스의 키: 16B, 자식 노드 주소 영역: 12B
            - 자식 노드의 개수 = (16 * 1024) / (16 + 12) = 585
        - 키 값의 크기가 2배가 된 경우
            - 자식 노드의 개수 = (16 * 1024) / (32 + 12) = 372
        - 인덱스의 키 값의 크기이 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미
- **B-Tree** **깊이**
    - B-Tree의 깊이가 3인 경우
        - 인덱스 키 값의 크기가 16B일 때
            - 최대 2억(585 * 585 * 585)개 정도의 키 값을 저장 가능
        - 인덱스 키 값의 크기가 32B일 때
            - 최대 5천만(372 * 372 * 372)개 정도의 키 값을 저장 가능
    - 인덱스 키 값이 커질수록 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고, B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 됨
- **선택도(기수성)**
    - 모든 인덱스 키 값 가운데 유니크한 값의 수
    - 중복된 값이 많아지면 기수성은 낮아지고 선택도 또한 떨어짐
    - 인덱스는 선택도가 높을수록 검색 대상이 줄어들어 빠르게 처리됨
- **읽어야 하는 레코드의 건수**
    - 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측
    - 즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

- **인덱스 레인지 스캔**
    - 레코드를 한 건만 읽는 경우와 한 건 이상을 읽는 경우의 용어가 서로 다르지만 이번 절에서는 **인덱스 레인지 스캔**이라고 표현
    - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
    - **스캔**
        - 루트 노드에서 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가서 필요한 레코드의 시작 지점을 찾아 리프 노드의 레코드를 순서대로 읽는 과정
    - **인덱스 레인지 스캔 단계**
        - 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.(인덱스 탐색(Index sek))
        - 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.(인덱스 스캔(Index scan))
        - 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.
- **인덱스 풀 스캔**
    - 인덱스의 처음부터 끝까지 모두 읽어들이는 방식
    - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용
    - 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 사용(레코드까지 읽어야 하는 경우 사용X)
    - 인덱스를 효율적으로 사용하지 못한 방식
- **루스 인덱스 스캔**
    - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리
    - `GROUP BY` 또는 집합 함수 가운데 `MAX()` , `MIN()` 함수에 대해 최적화를 하는 경우에 사용
- **인덱스 스킵 스캔**
    - 루스 인덱스 스캔과는 달리 `WHERE` 조건절의 검색을 위해 사용 가능
    - MySQL 8.0 버전의 인덱스 스킵 스캔 단점
        - `WHERE` 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
        - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)

## 8.3.5 다중 칼럼(Multi-column) 인덱스

- 두 개 이상의 컬럼으로 구성된 인덱스
- 인덱스가 2개의 컬럼으로 구성될 때 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있음
    - 즉, 두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미있음
- 따라서 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 오름차순으로 생성된 인덱스를 역순으로 읽으면 내림차순
- InnoDB에서 역순 스캔이 정순 스캔보다 느린 이유
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 케이스 A: `INDEX(dept_no, emp_no)`
- 케이스 B: `INDEX(emp_no, dept_no)`

```sql
SELECT * FROM dept_emp
WHERE dept_no='0002' AND emp_no >= 10114;
```

- 케이스 A의 경우 작업의 범위를 결정해 준다(작업 범위 결정 조건)
- 케이스 B의 경우 `dept_no='0002'` 과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건(필터링 조건)
- 작업 범위 결정 조건이 많을수록 좋다
- 작업 범위 결정 조건으로 사용할 수 없는 경우
    - NOT-EQUAL로 비교된 경우
    - LIKE ‘%??’ 형태로 문자열 패턴이 비교된 경우
    - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - 데이터 타입이 서로 다른 비교
    - 문자열 데이터 타입의 콜레이션이 다른 경우
- 다중 컬럼의 경우
    
    ```sql
    INDEX ix_test (column_1, column_2, column_3, ..., column_n)
    ```
    
    - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
        - column_1 컬럼에 대한 조건이 없는 경우
        - column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
    - 작업 범위 결정 조건으로 인덱스를 사용하는 경우
        - column_1 ~ column_(n - 1) 컬럼까지 동등 비교 형태(’=’ 또는 ‘IN’)로 비교
        - column_i 컬럼에 대해 다음 연산자 중 하나로 비교
            - 동등 비교
            - 크다 작다 형태
            - LIKE로 좌측 일치 패턴

# 8.5 전문 검색 인덱스

- **전문 검색**
    - 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색

## 8.5.1 인덱스 알고리즘

- **불용어 처리**
    - 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
- **어근 분석 알고리즘**
    - 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
- **n-gram 알고리즘**
    - 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
    - 본문을 무조건 몇 글자씩 잘라서 인덱싱 하는 방법
    - n은 인덱싱할 키워드의 최소 글자 수
- 불용어 처리를 무시하거나 사용자가 직접 불용어를 등록할 수 도 있음

## 8.5.2 전문 검색 인덱스의 가용성

- 전문 검색 인덱스를 사용하기 위한 2가지 조건
    - 쿼리 문장이 전문 검색을 위한 문법(MATCH … AGAINST …)을 사용
    - 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유

# 8.7 멀티 밸류 인덱스

- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 건이 1개의 인덱스 키 값을 가짐
- 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스로 정규화에 위배되는 형태
- JSON 데이터 타입을 지원하기 시작하면서 발생
- `MEMBER OF()` , `JSON_CONTAINS()` , `JSON_OVERLAPS()` 로 활용 가능

# 8.8 클러스터링 인덱스

- **클러스터링**
    - 여러 개를 하나로 묶는다

## 8.8.1 클러스터링 인덱스

- 테이블의 프라이머리 키에 대해서만 적용되는 내용. 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 함

## 8.8.2 세컨더리 인덱스에 미치는 영향

- InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있음

## 8.8.3 클러스터링 인덱스의 장점과 단점

- **장점**
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- **단점**
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
    - `INSERT` 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를  `DELETE` 하고 `INSERT` 하는 작업이 필요하기 때문에 처리 성능이 느림

## 8.8.4 클러스터링 테이블 사용 시 주의사항

- **클러스터링 인덱스 키의 크기**
- **프라이머리 키는 `AUTO-INCREMENT` 보다는 업무적인 컬럼으로 생성(가능한 경우)**
- **프라이머리 키는 반드시 명시할 것**
- **`AUTO-INCREMENT` 컬럼을 인조 식별자로 사용할 경우**

# 8.9 유니크 인덱스

## 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없음.
- **읽기 성능**
    - 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니다
- **쓰기 성능**
    - 새로운 레코드가 `INSERT` 되거나 인덱스 컬럼의 값이 변경되는 경우에는 인덱스 쓰기 작업이 필요
        - 이때, 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
        - 따라서, 유니크 인덱스의 쓰기가 더 느림

## 8.9.2 유니크 인덱스 사용 시 주의사항

- 유일성이 꼭 보장돼야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려해보자.

# 8.10 외래키

- InnoDB의 외래키 관리의 두 가지 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다
    - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다

## 8.10.1 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래 키 컬럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 된다.
- 자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.

## 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

- 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제된다.
    - 따라서 자식 테이블의 레코드를 변경하여 쓰기 잠금을 획득했을 때, 부모 테이블에서 레코드를 삭제하는 경우 쓰기 잠금이 해제될 때까지 기다린다.
