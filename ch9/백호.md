## 개요
### 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
	-  `SQL 파서`가 처리 및 문법 검증 및 파스 트리 생성
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
	- `옵티마이저` 에서
		- 불필요한 조건 제거 및 복잡한 연산의 단순화
		- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
		- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
		- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
	- `실행 계획` 생성
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
	- `스토리지 엔진` 에서 `실행 계획`으로 요청. 
	- 레코드 읽고 조인, 정렬 작업 수행
### 옵티마이저의 종류
- 두뇌와 같은 역할
- #### 비용 기반 최적화(MySQL 픽)
	- 여러가지 가능한 방법 중 단위 작업 비용과 테이블의 통계 정보를 이용하여 비용을 산출한다.
	- 최소 비용으로 처리되는 방식을 선택
- #### 규칙 기반 최적화
	- 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
	- 같은 쿼리는 같은 실행 계획
	- 데이터의 분포가 다양하기 때문에 DBMS에서 거의 사용되지 않음
## 기본 데이터 처리
### 풀 테이블 스캔과 풀 인덱스 스캔
#### 풀 테이블 스캔 조건
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔하는 편이 빠른 경우(테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
#### 풀 테이블 스캔 특징
- 대부분의 DBMS는 풀 테이블 스캔할 때 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.(InnoDB도 마찬가지)
	- Read ahead : 데이터가 앞으로 필요할 것을 예측하여 디스크에서 읽어 InnoDB 버퍼 풀에 둔다.(백그라운드에서 실행)
		- 옵션으로 실행 시점의 임계값을 설정할 수 있다.
		- 풀 인덱스 스캔에서도 동일하게 사용된다.
- `SELET count(*) FROM employees;` 
	- 풀 테이블 스캔을 하지 않고 풀 인덱스 스캔을 한다.
		- 인덱스는 특정 컬럼에만 걸려있기 때문에 전체 테이블보다 인덱스 페이지의 크기가 작다.
### 병렬 처리
- 하나의 쿼리를 여러 쓰레드가 나누어 동시에 처리
- 아무 조건없는 count 쿼리만 병렬 처리 가능.
- CPU의 코어 개수를 넘어서는 스래드 수는 오히려 성능이 떨어질 수 있다.
### ORDER BY
#### 인덱스 이용
- 장점 
	- SELECT 쿼리가 실행될 때 이미 인덱스로 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.
- 단점 
	- INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
	- 인덱스 때문에 디스크 공간이 더 많이 필요하다.
			- 인덱스의 개수가 늘어날 수 록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
- 인덱스를 이용하기 어려운 경우
	- 정렬 기준이 많아서 모든 인덱스를 생성하는 것이 불가능한 경우
	- GROUP BY의 결과 또는 DISTINCE 같은 처리의 결과를 정렬해야 하는 경우
	- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
	- 랜덤하게 결과 레코드를 가져와야 하는 경우
#### Filesort 이용
- 장점
	- 인덱스가 없어 추가/삭제가 빠르고 디스크 공간도 적고 메모리가 많이 필요없다.
- 단점
	- 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.
##### 소트 버퍼
- 정렬을 하기 위한 별도의 메모리 공간 - 기본 값 262KB
- 정렬해야할 레코드가 메모리보다 큰 경우 디스크에 임시 저장한다.
- 소트 버퍼 사이즈가 크다고 무족건 빨리 처리되지 않는다.
- 소트 버퍼는 세션 메모리 공간으로 공유해서 사용할 수 없다.
##### 정렬 알고리즘
- MySQL 서버의 정렬 방식 3가지
	- rowid : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬(투 패스 정렬 방식)
	- additional_fields : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식. 레코드의 칼럼들을 고정 사이즈로 메모리 저장(싱글 패스 정렬 방식)
	- packed_additional_fields : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식. 레코드의 칼럼들을 가변 사이즈로 메모리 저장(싱글 패스 정렬 방식)
- 싱글 패스 정렬 방식
	- 필요하지 않는 컬람까지 소프 버퍼에 담고 정렬을 수행한다.
- 투 패스 정렬 방식
	- 키 값만 정렬하고 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식
- 주로 싱글 패스 정렬 방식을 사용
- 투 패스 정렬을 사용하는 경우
	- 레코드의 크기가 소트버퍼 시스템 변수에 설정된 값보다 클 때
	- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때
- 싱글 패스는 건수가 작을 때 빠르고 투 패스는 건수가 많은 경우 효율적이다.
##### 정렬 처리 방법
- 종류
	- 인덱스를 사용한 정렬
	- 드라이빙 테이블만 정렬한 다음 조인
	- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
- 밑으로 갈 수 록 속도가 떨어짐
###### 인덱스를 이용한 정렬
- 조건
	- ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블.
	- ORDER BY의 순서대로 생성된 인덱스 조건.
	- WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건과 ORDER BY가 같은 인덱스 사용.
	- B-Tree 계열 인덱스
###### 조인의 드라이빙 테이블만 정렬
- 조건
	- 첫 번째로 읽히는 테이블의 칼럼만으로 ORDER BY절을 작성해야 한다.
	- 드리븐 테이블에 인덱스가 있다.
- 실행 순서
	- 인덱스로 조건 검색
	- 소트 버퍼(filesort)로 정렬
	- 최종 결과 조인
###### 임시 테이블을 이용한 정렬
- 조인한 결과를 임시 테이블에 저장한 후 정렬한다.
- 데이터가 많고 정렬 기준이 드리븐 테이블이 아니기 때문에 사용한다.
###### 정렬 처리 방법의 성능 비교
- 스트리밍 방식
	- 조건에 일치하는 레코드가 검색될 때마다 클라이언트로 전송하는 방식
	- 빠른 응답시간 보장
	- LIMIT을 걸명 처리 실행 시간을 상당히 줄일 수 있다.
	- 인덱스를 사용한 정렬 방식
- 버퍼링 방식
	- ORDER BY or GROUP BY는 스트리밍되는 것을 불가능하게 한다.
- JDBC는 자체적으로 버퍼링을 해버린다.
- 대용량 데이터가 필요한 경우 스트리밍 방식으로 바꿀 수 있다.
- 인덱스 사용 < 조인의 드라이빙 테이블만 정렬 < 임시 테이블 사용 후 정렬

#### GROUP BY 처리
- 인덱스를 이용할 때는 차례대로 읽는 인덱스 스캔 or 루스 인덱스 스캔 사용
- 인덱스를 사용하지 못할 때는 임시 테이블 사용
##### 인덱스 스캔을 이용하는 GROUP BY
- 드라이빙 테이블에 속한 칼럼만 이용해 GROUP BY하는 경우에 해당 칼럼에 인덱스가 있는 경우
- 추가 정렬이나 임시 테이블이 필요하지 않다.
##### 루스 인덱스 스캔을 사용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져온다.
- 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.
- 유니크한 값의 수가 적을 수록 성능이 향상된다. (건너뛰는 횟수 감소)
- 불가능한 경우
	- MIN, MAX  이외의 집합 함수가 사용된 경우
	- GROUP BY에 사용된 칼럼이 왼쪽부터 일치하지 않는 경우
		- `select col1, col2 from tb_test group by col2, col3;`
	- SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
##### 임시 테이블을 사용하는 GROUP BY
- 인덱스를 전혀 사용하지 못할 때
- ORDER BY 절이 없으면 MySQL 8.0부터는 묵시적 정렬이 실행되지 않는다.

#### DISTINCT 처리
 - 집합 함수와 함께 사용되는 경우
	 - 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔한다.
	 - 인덱스를 사용할 수 없으면 임시테이블이 필요하다.
 - 집합 함수가 없는 경우

#### 내부 임시 테이블 활용
- MySQL 엔진이 사용하는 임시 테이블 메모리로 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.
- 쿼리 처리가 완료되면 자동으로 삭제된다.
##### 메모리 임시 테이블고과 디스크 임시 테이블
- 메모리는 TempTable 스토리지 엔진
	- 가변길이 타입
- 디스크는 InnoDB 스토리지 엔진
	- 트랜잭션 지원
##### 임시 테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 DISTINCT가 사용된 쿼리
- 쿼리의 실행 계회에서 select_type이 DERIVED인 쿼리
##### 임시 테이블이 디스크에 생성되는 경우
- UNION이나 UNION ALL 에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 큰 경우


## 오류
288p 인덱스 이용 장점 SELECT아닌가?

## 질문
 - 정렬을 DB 서버에서 하는 것과 어플리케이션 서버에서 하는 것 중 어떤 것을 선택하는 것이 좋을까?
	 - 소트버퍼의 사이즈를 고려해서 선택하는 것은 어떨까?

